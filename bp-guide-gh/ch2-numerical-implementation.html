
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Numerical Implementation &#8212; Phase Field Method Recommended Practices</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'bp-guide-gh/ch2-numerical-implementation';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Generation and Curation" href="ch3-data-generation-and-curation.html" />
    <link rel="prev" title="Model Formulation" href="ch1-model-formulation.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/pfhub-logo.jpg" class="logo__image only-light" alt="Phase Field Method Recommended Practices - Home"/>
    <img src="../_static/pfhub-logo.jpg" class="logo__image only-dark pst-js-only" alt="Phase Field Method Recommended Practices - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Phase Field Method Recommended Practices
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Importing GH Wiki</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ch1-model-formulation.html">Model Formulation</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Numerical Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3-data-generation-and-curation.html">Data Generation and Curation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4-software-development.html">Software Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5-problem-setup.html">Problem Set-Up</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch6-result-dissemination.html">Result Dissemination</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Default Pages</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../defaults/markdown.html">Markdown Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../defaults/markdown-notebooks.html">Notebooks with MyST Markdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="../defaults/notebooks.html">Content with notebooks</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/usnistgov/pf-recommended-practices" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/usnistgov/pf-recommended-practices/issues/new?title=Issue%20on%20page%20%2Fbp-guide-gh/ch2-numerical-implementation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/bp-guide-gh/ch2-numerical-implementation.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Numerical Implementation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-collection-of-numerical-methods">Choosing an appropriate collection of numerical methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#start-simple-then-selectively-move-to-more-complex-methods">Start simple, then selectively move to more complex methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-spatial-discretization">Choosing a spatial discretization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-difference">Finite difference</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-volume">Finite volume</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-element">Finite element</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fourier-pseudospectral">Fourier pseudospectral</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-discretization-summary-table">Spatial Discretization Summary Table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#adaptive-mesh-refinement">Adaptive Mesh Refinement</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#methods-for-applying-boundary-conditions-on-internal-boundaries">Methods for Applying Boundary Conditions on Internal Boundaries</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-time-integration-method">Choosing a Time Integration Method</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#explicit-vs-implicit-methods">Explicit vs. Implicit Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity">Complexity</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#time-step-cost-and-size">Time step cost and size</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-usage">Memory usage</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coupling-and-consistency">Coupling and Consistency</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#semi-implicit-and-imex-methods">Semi-Implicit and ImEx Methods</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#time-step-adaptivity">Time Step Adaptivity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-guidelines">General Guidelines</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-linear-and-nonlinear-solvers-if-needed">Choosing Linear and Nonlinear Solvers (If Needed)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#when-you-might-need-linear-or-nonlinear-solvers">When You Might Need Linear or Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-nonlinear-solvers">Types of Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-linear-solvers">Types of Linear Solvers</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-parallelism-approach">Choosing an appropriate parallelism approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#distributed-memory">Distributed memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#shared-memory">Shared memory</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself">Choosing appropriate numerical libraries and/or what to write yourself</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#investigate-existing-solutions-before-writing-your-own">Investigate existing solutions before writing your own</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#existing-phase-field-codes-and-frameworks">Existing phase-field codes and frameworks</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-how-existing-libraries-interact">Consider how existing libraries interact</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-local-expertise">Consider local expertise</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-licensing">Consider licensing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further reading</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solver-methods">Solver Methods:</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="numerical-implementation">
<h1>Numerical Implementation<a class="headerlink" href="#numerical-implementation" title="Link to this heading">#</a></h1>
<p>When writing your own phase-field simulation code or when choosing among
existing codes, the numerical implementation of the model is an important
consideration. This section of Phase-Field Recommended Practices Guide is split
into two subsections – one focused on choosing appropriate numerical methods
and one focused on choosing whether to code your own solvers or use existing
libraries (and how to choose between existing libraries). Although these
subsections are presented sequentially, these choices are more iterative than
sequential. For example, you may start out deciding that a certain set of
numerical methods are promising, but then switch to others after considering
the availability of libraries.</p>
<section id="choosing-an-appropriate-collection-of-numerical-methods">
<h2>Choosing an appropriate collection of numerical methods<a class="headerlink" href="#choosing-an-appropriate-collection-of-numerical-methods" title="Link to this heading">#</a></h2>
<p>There is no consensus on what the “best” numerical methods for phase-field
modeling are. In fact, given the diversity of the models and settings under the
phase field umbrella, it is unlikely that any single collection of methods
would be optimal for all phase-field modeling. Instead, a wide variety of
numerical methods are used in the literature. For most problems of interest
there are multiple numerical methods that can be used to obtain a solution to
the model equations (and perhaps some methods that <em>cannot</em> obtain a
solution). Several factors to consider when choosing between numerical methods
are:</p>
<ul class="simple">
<li><p>General computational performance</p></li>
<li><p>Appropriateness for the planned computing hardware (e.g., GPUs)</p></li>
<li><p>Scalability, ease of implementation</p></li>
<li><p>Availability of libraries</p></li>
</ul>
<p>Each researcher may have their own unique balance of these factors that leads
them to choose a numerical approach.</p>
<p>These choices can be very important. The performance of different methods for a
given problem can vary by orders of magnitude. Likewise the complexity to
implement the methods can vary by orders of magnitude – some solvers can be
written in a few tens of lines of code; some may take tens of thousands of
lines. The path-dependency of the choices are also variable. Transitioning from
a spectral code to a finite element code might necessitate an entire
rewrite. Transitioning from one implicit time integration method to another may
take a few hours.</p>
<p>A phase-field code involves a few different types of numerical
methods. Different choices for each type are possible, but not all combinations
are possible or advisable. In the end, to determine the numerical
implementation for your phase-field model you will need to decide on a
collection of numerical methods and approaches that are suitable for your
problem and work well together.</p>
<p>Before deciding on a strategy for a numerical implementation, we strongly
recommend that you put thought into your problem(s) of interest. Understanding
the governing equations, boundary conditions, initial conditions, coupled
physics, expected symmetries and other factors discussed in the <a class="reference external" href="https://github.com/usnistgov/pfhub/wiki/Model-Formulation">Model
Formulation section</a>
will aid you in deciding on how to implement your model numerically.</p>
<section id="start-simple-then-selectively-move-to-more-complex-methods">
<h3>Start simple, then selectively move to more complex methods<a class="headerlink" href="#start-simple-then-selectively-move-to-more-complex-methods" title="Link to this heading">#</a></h3>
<p>In general, we recommend that you start with a simple method and then add
complexity selectively where justified. There are a few benefits to this
approach.</p>
<ol class="arabic simple">
<li><p>Simpler methods are usually easier to implement, decreasing the time from
starting to running your first test simulation. This gives you an earlier
opportunity to identify unexpected issues in your model formulation that you
didn’t catch before implementing it. Part of what makes a simpler method
easier to implement is that a simpler method is often easier to debug and/or
there are fewer ways for it to fail.</p></li>
<li><p>The simpler implementation can be a backup option if the development of a
more complex option takes longer than expected. Even following the
<a class="reference external" href="https://github.com/usnistgov/pfhub/wiki/Software-Development">recommended practices for software
development</a>,
code development times can be unpredictable. A suboptimal backup
implementation might get you through your first milestones while you’re
debugging a more advanced method.</p></li>
<li><p>You may learn that the simpler option fulfills your needs. Complex methods
aren’t always better; the problem of interest might not need or justify
investment in more complex methods.</p></li>
<li><p>Even if the simpler method doesn’t fulfill your needs, it may illuminate
where added complexity is worth investigating (“these small explicit time
steps are bogging me down, I should try an implicit time integrator”, “I’m
wasting so many resources in this area where nothing happens, I should try
adaptive meshing”).</p></li>
<li><p>Solutions obtained with the simpler method can be used as reference
solutions as part of your <a class="reference external" href="https://github.com/usnistgov/pfhub/wiki/Software-Development">code verification
strategy</a>. Obtaining
the same solution with two methods is no guarantee that both are correct,
but it is an encouraging sign. And certainly, if two methods yield different
solutions, the implementations require attention.</p></li>
</ol>
<p>This all said, there may be some compelling reasons to start with more complex
methods. One such reason is if the method is already implemented in an
off-the-shelf package. Other numerical considerations could come into play: an
unpreconditioned Krylov solver is <em>simpler</em> than a preconditioned one, but the
preconditioner stabilizes the solution and may be more forgiving for
non-optimized simulation parameters in an initial exploratory phase for a
project and may be <em>simpler to use</em>.</p>
<p>Additionally, we also recommend initially implementing a simpler form of your
model and the building up to the full model, particularly if you are new to the
toolchain that you’re using. There are classes of issues that with your
numerical implementation that show up in even very simple calculations (MPI
communication issues, stencil issues, scaling issues, etc.), and it’s best to
deal with those as soon as possible. Note: this approach works best when the
simplified model is a simplified version of the <em>PDE</em>, not simply a simplified
version of the <em>physics</em>. Sometimes models at different levels of complexity
have a very different structure. A few examples of simpler starting models are:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Target Model</p></th>
<th class="head text-center"><p>Simplified Variant</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>BM1 (Cahn-Hilliard)</p></td>
<td class="text-center"><p>Diffusion equation, then add the higher order term</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>BM2 (Coupled Cahn-Hilliard-Allen-Cahn)</p></td>
<td class="text-center"><p>Cahn-Hilliard by itself, add one Allen-Cahn equation, then two, then all of them</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>BM4 (Elastic Precipitate)</p></td>
<td class="text-center"><p>Cahn-Hilliard by itself, then add elasticity</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="choosing-a-spatial-discretization">
<h3>Choosing a spatial discretization<a class="headerlink" href="#choosing-a-spatial-discretization" title="Link to this heading">#</a></h3>
<p>Four main types of spatial discretizations are used for phase-field modeling:
finite difference, finite volume, finite element, and Fourier
pseudospectral. Each of these methods has been used for simulation results
uploaded to PFHub. Examples for each method are:</p>
<ul class="simple">
<li><p>finite difference: <a class="reference external" href="https://github.com/memphis-snl/memphis">Memphis</a>,
<a class="reference external" href="https://github.com/usnistgov/HiPerC">HiPerC</a></p></li>
<li><p>finite volume: <a class="reference external" href="https://github.com/usnistgov/fipy">FiPy</a></p></li>
<li><p>finite element: <a class="reference external" href="https://github.com/idaholab/moose">MOOSE</a>,
<a class="reference external" href="https://github.com/prisms-center/phaseField">PRISMS-PF</a>,
<a class="reference external" href="https://github.com/FEniCS">Fenics</a></p></li>
<li><p>Fourier pseudospectral: <a class="reference external" href="https://code.ornl.gov/meumapps/meumapps">MEUMAPPS</a></p></li>
</ul>
<p>Here we give a brief overview of the strengths and weaknesses of each of these
spatial discretization approaches. Aiming for brevity over completeness, this
discussion skips over the considerable nuance in the capabilities of these
methods.</p>
<section id="finite-difference">
<h4>Finite difference<a class="headerlink" href="#finite-difference" title="Link to this heading">#</a></h4>
<p>Finite difference discretizations are one of the most common spatial
discretizations for phase-field codes. The field data is stored on the vertices
of the mesh and derivatives are approximated using variable values at the point
of interest and/or neighboring points. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_difference_method">Wikipedia
page</a> for a general
introduction. While many flavors of finite difference methods exist, most
finite difference phase-field codes use structured, uniform grids.</p>
</section>
<section id="finite-volume">
<h4>Finite volume<a class="headerlink" href="#finite-volume" title="Link to this heading">#</a></h4>
<p>With finite volume methods, the field data is stored for each element in the
mesh (i.e., the “finite volume”), and changes to the field data are calculated
by summing the fluxes through the faces of the element. Therefore,
finite-volume methods are inherently conservative. Because the flux
calculations are done on the faces, finite volume methods can be used on
unstructured meshes. Also, as a result of the emphasis on fluxes, finite volume
methods solve the weak form of a PDE. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_volume_method">Wikipedia
page</a> for a general
introduction.</p>
</section>
<section id="finite-element">
<h4>Finite element<a class="headerlink" href="#finite-element" title="Link to this heading">#</a></h4>
<p>Finite element methods are the most complex of the common spatial
discretization methods for phase-field codes. In a finite element method, field
values are stored on pre-defined places of each element (the “nodes”). The
field variables in the element are continuously represented by a function of
pre-defined type (e.g., bilinear) that passes through the field values at each
node (the “shape function”). Derivatives are calculated through derivatives of
the shape function. The field variables are evolved using volumetric integrals
over the element, where the integrals are calculated using
<a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_quadrature">quadrature</a>. Therefore,
although field variables are stored at the nodes for the element, the evolution
expressions are calculated on “quadrature points”, which often are not in the
same locations as the nodes. Due to the expressions being integral expressions,
finite element methods operate on the weak form of a PDE. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_element_method">Wikipedia
page</a> for a general
introduction.</p>
</section>
<section id="fourier-pseudospectral">
<h4>Fourier pseudospectral<a class="headerlink" href="#fourier-pseudospectral" title="Link to this heading">#</a></h4>
<p>Along with finite difference methods, Fourier pseudospectral methods are
historically a common spatial discretization for phase-field codes. Although
Fourier pseudospectral methods have similar theoretical underpinnings as finite
element methods, in practice, implementing a Fourier pseudospectral code is
very different from the other methods listed here. In comparison to the other
methods with a local representation of the fields, the Fourier pseudospectral
method has a global representation of the fields using sines and cosines. As a
result, derivatives of fields can be calculated using fast Fourier transforms
(FFTs); in the reciprocal space, a spatial derivative becomes a multiplication
with a wavenumber. This FFT-centric approach avoids the need for linear solvers
that the other spatial discretization may need, leading to a popular
semi-implicit time integration scheme (see below for more details). Fourier
pseudospectral methods have the fastest spatial convergence of any scheme here,
exponential convergence (as compared to polynomial convergence for the other
methods). To balance these advantages, Fourier pseudospectral methods have
restrictions that the other methods do not. The reliance on FFTs means that
periodic boundary conditions are the only type of boundary conditions
possible. The FFTs also require a uniform, structured mesh, so no adaptive
meshing is possible in most situations (e.g., unless a coordinate tranformation
is possible to project onto a uniform, structured mesh).</p>
</section>
<section id="spatial-discretization-summary-table">
<h4>Spatial Discretization Summary Table<a class="headerlink" href="#spatial-discretization-summary-table" title="Link to this heading">#</a></h4>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head text-center"><p>Strengths</p></th>
<th class="head text-center"><p>Weaknesses</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Finite difference</strong></p></td>
<td class="text-center"><p>Simple to code <br/> Minimal computational overhead <br/> Adaptive meshing is possible</p></td>
<td class="text-center"><p>Conservation is not guaranteed depending on the stencil <br/> Difficult to use on complex geometries (more complicated on non-uniform grids and much more complicated (impossible?) on unstructured grids) <br/> Adaptive meshing is constrained by need for a structured mesh</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Finite volume</strong></p></td>
<td class="text-center"><p>Naturally conservative <br/> Adaptive meshing is possible <br/> Can be used for arbitrary geometries (via unstructured meshes) <br/> Simpler to implement than finite element methods</p></td>
<td class="text-center"><p>More complicated to implement than finite difference or Fourier-pseudospectral <br/> Orders of accuracy higher than two substantially increase complexity</p></td>
</tr>
<tr class="row-even"><td><p><strong>Finite element</strong></p></td>
<td class="text-center"><p>Adaptive meshing is possible <br/> Can be used for arbitrary geometries (via unstructured meshes) <br/> Fairly straightforward extension to higher orders of accuracy <br/> Popularity in other domains may aid multiphysics coupling</p></td>
<td class="text-center"><p>Most complicated to code <br/> Most computational overhead</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Fourier pseudospectral</strong></p></td>
<td class="text-center"><p>Simple to code <br/> Highest spatial error convergence rate <br/> “Free” implicit handling of linear terms</p></td>
<td class="text-center"><p>Limited to periodic boundary conditions <br/> Limited to uniform, structured meshes</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="adaptive-mesh-refinement">
<h4>Adaptive Mesh Refinement<a class="headerlink" href="#adaptive-mesh-refinement" title="Link to this heading">#</a></h4>
<p>Adaptive mesh refinement (AMR) is the process of changing the mesh for a
calculation so that the mesh is finer in regions where the spatial error is
expected to be high (e.g., where fields are changing rapidly) and coarser where
the spatial error is expected to be low (e.g., where fields are changing
slowly). An example of adaptive mesh refinement for the PFHub Benchmark 3
problem is shown below:</p>
<p>(Insert BM3 AMR example)</p>
<p>Note that in this example, the mesh is the finest near the solid-liquid
interface and coarsest far from the interface in the liquid. PFHub Benchmark 3
is an example of a problem where adaptive meshing is particularly useful – at
any given time, the area of the interfacial region is a small fraction of the
total area. The interfacial region needs a fine mesh to resolve the transition
of the order parameter, but a coarse mesh can be used far into the liquid where
only thermal diffusion is active. The <a class="reference external" href="https://pages.nist.gov/pfhub/simulations/3a.1/">uploaded
results</a> with by far the
fastest run times for this simulations, using MOOSE and PRISMS-PF, both take
advantage of adaptive meshing.</p>
<p>In other cases, the benefits of adaptive mesh refinement may not be worth the
computation overhead and increase in complexity. The early stages of evolution
for PFHub Benchmark 1 are an example of this case. The composition field is
rapidly varying almost everywhere in the domain, and coarsening the mesh in any
location would likely introduce substantial error.</p>
<p>Three main adaptive meshing schemes are:</p>
<ul class="simple">
<li><p>Adaptive unstructured meshes (full freedom of mesh shape, but high overhead)</p></li>
<li><p>Block-structured meshes (a mesh made of rectangular regions at different
levels of refinement)</p></li>
<li><p>Quadtree/octree meshes (hierarchical mesh where refinement occurs by
bisecting parent elements)</p></li>
</ul>
</section>
<section id="methods-for-applying-boundary-conditions-on-internal-boundaries">
<h4>Methods for Applying Boundary Conditions on Internal Boundaries<a class="headerlink" href="#methods-for-applying-boundary-conditions-on-internal-boundaries" title="Link to this heading">#</a></h4>
<p>Although many phase-field problems of interest can be solved in a rectangular
domain with boundary conditions applied on the boundaries of the computational
domain, in some cases, you may want to apply boundary conditions along an
<em>internal</em> boundary. There are two typical circumstances where this occurs. One
circumstance is where the domain of interest has some complex (perhaps dynamic)
shape but you do not want to have a body-fitting mesh (e.g., due to code or
method limitations). The second circumstance is that you are using a Fourier
pseudospectral method and want to impose non-periodic boundary conditions.</p>
<p>Two methods have been developed to handle this issue – to impose boundary
conditions internally in a computational domain that decouple the solution
domain from the computational domain. The <a class="reference external" href="https://epubs.siam.org/doi/book/10.1137/1.9780898717464">immersed interface
method</a> is a
sharp-interface method for imposing internal boundary conditions. The <a class="reference external" href="https://doi.org/10.1088/0965-0393/20/7/075008">smoothed
boundary method</a> is a diffuse
interface method for imposing internal boundary conditions. In some
circumstances, these methods may provide a performant way to side-step the
restrictions on the meshes for Fourier pseudospectral or finite difference
phase-field codes.</p>
<p>To date, none of the PFHub uploads have used these methods, but Benchmark 6b is
an example of where it may be appropriate.</p>
</section>
</section>
<section id="choosing-a-time-integration-method">
<h3>Choosing a Time Integration Method<a class="headerlink" href="#choosing-a-time-integration-method" title="Link to this heading">#</a></h3>
<p>If your model is time dependent, you will need to choose a scheme for
integrating in time (or time stepping). A time integrator is typically
described in terms of its order of accuracy and whether it is explicit or
implicit. Classic examples include:</p>
<ul class="simple">
<li><p>Forward Euler (FE) method, a first-order explicit method</p></li>
<li><p>Backward Euler (BE) method, a first-order implicit method</p></li>
<li><p>Crank-Nicolson (CN) method, a second-order semi-implicit method</p></li>
</ul>
<p>These methods often serve as prototypes for other families of general-purpose
time integrators that have successfully been employed in phase-field codes.
<strong>Many of the community codes that participate in PFHub already offer
selections of time integrators; the documentation of those packages will often
include suggestions on what to choose for your model.</strong></p>
<p>If you are using a code that does not provide its own time integrators or you
are writing your own code, there are many factors to consider when picking a
scheme.  <strong>The “best” time integrator for your model will depend upon your
governing equations, the spatial discretization, any required linear and
nonlinear solvers, and even the computational hardware you have available.  You
may need to experiment with different schemes to find the right balance of
performance and accuracy for your needs.</strong>  This last step can require
significant amounts of time and coding.</p>
<p>If you need to implement your own time integrator, we provide a brief overview
of integration schemes and their strengths and weaknesses, but this discussion
serves as a relatively high-level overview.  Time integration is an active area
of research across the phase-field, applied math, and computational science
communities, and it is impossible to cover every consideration.</p>
<section id="explicit-vs-implicit-methods">
<h4>Explicit vs. Implicit Methods<a class="headerlink" href="#explicit-vs-implicit-methods" title="Link to this heading">#</a></h4>
<p>In explicit methods, the solution at a future time step is only a function of
previous time steps. By comparison, for implicit methods, the solution at a
future time step is a function of the future and previous time steps. Forward
Euler, for example, has the form <span class="math notranslate nohighlight">\((u^{n+1} - u^n) / \Delta t = f(u^n)\)</span>, and
Backward Euler has the form <span class="math notranslate nohighlight">\((u^{n+1} - u^n) / \Delta t = f(u^{n+1})\)</span>.
Broadly, we can summarize the strengths (+) and weaknesses (-) as follows:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head text-center"><p>Explicit</p></th>
<th class="head text-center"><p>Implicit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Code complexity</p></td>
<td class="text-center"><p>+</p></td>
<td class="text-center"><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>Time step cost</p></td>
<td class="text-center"><p>+</p></td>
<td class="text-center"><p>-</p></td>
</tr>
<tr class="row-even"><td><p>Time step size</p></td>
<td class="text-center"><p>-</p></td>
<td class="text-center"><p>+</p></td>
</tr>
<tr class="row-odd"><td><p>Memory usage</p></td>
<td class="text-center"><p>+</p></td>
<td class="text-center"><p>-</p></td>
</tr>
</tbody>
</table>
</div>
<p>However, there are notable exceptions for each row.  Additionally, choices that
influence each row of the above table also affect the overall consistency of a
scheme.</p>
<section id="complexity">
<h5>Complexity<a class="headerlink" href="#complexity" title="Link to this heading">#</a></h5>
<p>In general, explicit solvers do not require nonlinear solvers for the
time-dependent portions of the model, and linear solvers are either not
required (finite difference methods, many finite volume methods) or only
require the inversion of the mass matrix (finite element methods).  This
reduction in necessary solver components can reduce overall development time
(less code, less debugging), which may allow you to start running simulations
sooner.  Additionally, from a working FE code, it is straightforward to
implement either explicit/embedded Runge-Kutta methods, Adams-Bashforth
methods, or Predictor-Corrector (e.g., Milne) methods.</p>
<p>By comparison, fully implicit methods will usually require the implementation
of nonlinear and linear solvers.  Some methods might allow for one of these
eliminated: for example, the linearly implicit Rosenbrock Methods do not
require a nonlinear solver.  However, most codes will adopt a modified Newton
method where a linear solver is required at each nonlinear iteration.  The BE
method can be a prototype for various flavors of implicit Runge-Kutta methods
(IRK, DIRK, SDIRK, ESDIRK, etc.), Adams-Moulton methods, or Backward
Differentiation Formula (BDF) methods, but there are fewer similarities between
these methods than there is between the explicit methods.</p>
</section>
<section id="time-step-cost-and-size">
<h5>Time step cost and size<a class="headerlink" href="#time-step-cost-and-size" title="Link to this heading">#</a></h5>
<p>Due to the need to solve a (non-)linear system of equations, one time step of
an implicit method can be orders of magnitude more expensive than one time step
of an explicit method.  If iterative solvers are employed, the cost of each
step will also vary with the overall conditioning of the system from one time
step to the next.</p>
<p>However, it is well-known that explicit solvers often have strict requirements
for the stable time step size (e.g., <span class="math notranslate nohighlight">\(\Delta t \propto \Delta x^2\)</span> for FE
discretization of heat equation).  By comparison, most implicit methods are
either unconditionally stable or have much wider stability regions For a given
time interval and similar order of accuracy, an explicit method will usually
take many more time steps than an implicit method, which can increase the
accumulated roundoff error (this will depend on the particular schemes).  Also,
if the increase in stable step size is large enough, the implicit method may
end up requiring less walltime to solve the entire model.</p>
</section>
<section id="memory-usage">
<h5>Memory usage<a class="headerlink" href="#memory-usage" title="Link to this heading">#</a></h5>
<p>Explicit and implicit schemes can have different requirements on the amount of
RAM that is needed for the same overall problem size. If we consider the FE
and BE methods, both can be implemented with two vectors: one for <span class="math notranslate nohighlight">\(u^n\)</span> and one
for <span class="math notranslate nohighlight">\(u^{n+1}\)</span>.  For the explicit method, this places no restrictions on the
resulting solver algorithm: you can solve for <span class="math notranslate nohighlight">\(u^{n+1}\)</span> and then either copy it
to <span class="math notranslate nohighlight">\(u^n\)</span> or swap the associated pointers in the code.  However, economizing
memory in the implicit scheme limits your method to classical iterative methods
like Newton-Gauss-Seidel, which may not offer satisfactory performance in your
overall code.  More powerful solvers like Newton-Krylov methods will require
more memory, but will allow the implicit method to converge quickly.</p>
<p>While not universally true, this leads to a rule of thumb that for equal
numbers of stages or steps, an explicit scheme will require less memory than an
implicit scheme. However, low-order implicit schemes may be able to take
significantly larger time steps than even high-order explicit schemes, which
can equalize the overall cost.</p>
</section>
</section>
<section id="coupling-and-consistency">
<h4>Coupling and Consistency<a class="headerlink" href="#coupling-and-consistency" title="Link to this heading">#</a></h4>
<p>Comment about how hard it can be to solve multiple equations simultaneously.
Do you solve multiple small systems or one large system?</p>
</section>
<section id="semi-implicit-and-imex-methods">
<h4>Semi-Implicit and ImEx Methods<a class="headerlink" href="#semi-implicit-and-imex-methods" title="Link to this heading">#</a></h4>
<p>In semi-implicit and implicit-explicit (ImEx) methods, different terms in the
governing equations are approximated by different implicit or explicit schemes.
These methods have a long history in the phase-field community and, as
suggested by their name, behave “in between” explicit and implicit schemes.
For example, convex splitting methods for the Cahn-Hilliard equation naturally
result in implicit and explicit terms.  Semi-implicit methods are also the
default choice in Fourier pseudospectral methods.  In more general models,
physics with “fast” time scales may be solved implicitly, while physics with
“slow” time scales may be solved explicitly.</p>
<p>The resulting schemes are usually much cheaper than fully implicit methods.
The largest stable or accurate time step size will typically be reduced
compared to an implicit scheme, but is usually much larger than an explicit
scheme.</p>
</section>
<section id="time-step-adaptivity">
<h4>Time Step Adaptivity<a class="headerlink" href="#time-step-adaptivity" title="Link to this heading">#</a></h4>
<p>When choosing the time step size of an integrator, there is a need to balance
computational cost (i.e., larger step size, fewer time steps, lower cost) and
the numerical accuracy (smaller step size, better approximation of time
derivatives, lower error, and improved solvability).  Just as we can adaptively
refine and coarsen the mesh of a spatial discretization to improve accuracy or
reduce the computational cost, we can also employ adaptive methods when
choosing a time step.  In many Runge-Kutta and Rosenbrock methods, the scheme
provides an embedded estimate of the error in the solution.  A weighted norm of
this error can be compared to a specified tolerance, which decides if the time
step is accepted or rejected, and then the step size can be adjusted by a PID
controller or some other filter.  In multistep methods, we can derive estimates
of the leading truncation error, which then allows us to check the accuracy of
a step.  However, different methods will have different rules about how to
change step size: Runge-Kutta methods can usually change the step size by large
amounts every time step, but multistep methods often have to change by smaller
amounts or only every few time steps.</p>
<p>When properly implemented, adaptive time stepping improves confidence in
solution quality, minimizes the chance of your solution “exploding” from too
large of a time step, and can save time with expensive schemes by reducing step
size in fast-changing regions of time and increasing it when the dynamics are
slower.</p>
</section>
<section id="general-guidelines">
<h4>General Guidelines<a class="headerlink" href="#general-guidelines" title="Link to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>For initial development, it is best to start with simpler schemes like
Forward Euler. This will allow you to gain an understanding of your model’s
behavior, check for bugs in the basic mechanics of the code, and start
estimating the cost of simulations. If the model is inexpensive or you don’t
plan to use the code more than a few times, a basic integrator may be all
you need.</p></li>
<li><p>If you are forced to use small time steps on the scale of time you want to
simulate, you might consider an implicit integrator (again, start with
simpler schemes like BE or CN).</p></li>
<li><p>If your model contains varying time scales (e.g. from coupled physics,
concentration-dependent mobility) and you have difficulty maintaining a
stable time step or find that the convergence is unpredictable, adaptive
time stepping will likely be helpful. If you are using explicit schemes,
consider trying an embedded Runge-Kutta method. For implicit schemes, you
might try a higher-order BDF method if your right-hand-side function is
expensive to compute or a diagonally implicit Runge-Kutta method.</p></li>
<li><p>If you need to solve an elliptic governing equation simultaneously (<a class="reference external" href="https://pages.nist.gov/pfhub/benchmarks/benchmark6-hackathon.ipynb/">as in
Benchmark
6</a>),
the resulting system of differential-algebraic equations (DAEs) is likely to
be very stiff. Even if the time-dependent portion is not expensive to
evaluate, the cost of constantly performing the elliptic solve can be
significant with explicit methods. Consider BDF methods, diagonally implicit
or additive Runge-Kutta methods, or Rosenbrock methods.</p></li>
<li><p>For coupled physics, carefully examine how each equation is related. Some
time-dependent terms may be less strongly coupled than others or be more
costly to evaluate in a fully implicit scheme, so you might consider a
semi-implicit or ImEx scheme such as an additive Runge-Kutta method.</p></li>
</ol>
<p>Many families of time integrators have variants that can choose the time step
size adaptively. Additionally, the Adams and BDF methods have implementations
with variable order of accuracy. <strong>If your code does not already provide time
integration, many packages exist for various flavors of time steppers</strong>,
including but not limited to <a class="reference external" href="https://github.com/LLNL/sundials">SUNDIALS</a>,
<a class="reference external" href="https://petsc.org/release/docs/manualpages/TS/index.html">PETSc TS</a>,
<a class="reference external" href="https://trilinos.github.io/tempus.html">Tempus</a>, and
<a class="reference external" href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p>
</section>
</section>
<section id="choosing-linear-and-nonlinear-solvers-if-needed">
<h3>Choosing Linear and Nonlinear Solvers (If Needed)<a class="headerlink" href="#choosing-linear-and-nonlinear-solvers-if-needed" title="Link to this heading">#</a></h3>
<p>Depending on your spatial/temporal discretizations and whether you need to
solve any elliptic governing equations, you may need to implement or choose a
set of appropriate linear and nonlinear solvers.  <strong>Many codes will already
provide solvers that work well for their packages.</strong>  For example, if you were
implementing a model in FEniCS, the developers have already exposed options
from PETSC’s nonlinear and linear solver interfaces and you can easily switch
between different dense, sparse, and iterative methods.  Even if you are
implementing your own code, <strong>solvers may already be available from the
libraries you link to and you may not need to write your own.</strong>  For example,
SUNDIALS provides a set of linear and nonlinear solvers that are already
optimized for its time-stepping routines.</p>
<p>If you need to write your own solvers, we provide some general guidelines
below.</p>
<section id="when-you-might-need-linear-or-nonlinear-solvers">
<h4>When You Might Need Linear or Nonlinear Solvers<a class="headerlink" href="#when-you-might-need-linear-or-nonlinear-solvers" title="Link to this heading">#</a></h4>
<p>The need for (non)linear solvers in a given code will depend on the equations
you are solving and your choices of spatiotemporal discretizations.  As a
simple example, we can consider incremental changes to a 1D Allen-Cahn-type
model for a driven phase transformation (i.e., a simplified form of BM3).  For
a spatial discretization with centered finite differences and time integration
by Forward Euler, the equation at each point of the mesh will be of the form</p>
<div class="math notranslate nohighlight">
\[
\phi_i^{n+1} = \phi_i^n + \Delta t ( \phi_{i+1}^n - 2 \phi_i^n + \phi_{i-1}^n - g'(\phi_i^n) - Q p'(\phi_i^n) )
\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> corresponds to the time step of the solution, <span class="math notranslate nohighlight">\(i\)</span> corresponds to the
grid points, <span class="math notranslate nohighlight">\(\Delta t\)</span> is the time step, <span class="math notranslate nohighlight">\(Q\)</span> is the driving force, and <span class="math notranslate nohighlight">\(g'\)</span>
and <span class="math notranslate nohighlight">\(p'\)</span> are the derivatives of the double-well and interpolation function,
respectively.  Note that we assume values of 1 for mobility, <span class="math notranslate nohighlight">\(\kappa / \Delta
x^2\)</span>, and the well height.  All of the quantities on the right-hand side are
known: we can evaluate each <span class="math notranslate nohighlight">\(\phi_i^{n+1}\)</span> directly without needing to perform
any linear or nonlinear solvers.  This is sometimes referred to as
“linearization through explicit time stepping.”</p>
<p>A common approach to improve time step stability of a PFM is to employ a convex
split of the governing equations where we decompose the nonlinear terms as
<span class="math notranslate nohighlight">\(g(\phi) = g_+ (\phi) + g_- (\phi)\)</span> and <span class="math notranslate nohighlight">\(p(\phi) = p_+ (\phi) + p_- (\phi)\)</span>,
where <span class="math notranslate nohighlight">\(+\)</span> indicates the purely convex portion of the function and <span class="math notranslate nohighlight">\(-\)</span> is the
remaining (presumably concave) portion.  Typically, we solve this convex-split
approach by ImEx methods such as Forward-Backward Euler:</p>
<div class="math notranslate nohighlight">
\[
\phi_i^{n+1} - \Delta t ( \phi_{i+1}^{n+1} - 2\phi_i^{n+1} + \phi_{i-1}^{n+1} - g_+'(\phi_i^{n+1}) - Qp_+'(\phi_i^{n+1}) ) = \phi_i^n - \Delta t ( g_-'(\phi_i^n) + Qp_-'(\phi_i^n) )
\]</div>
<p>This system of equations is now semi-implicit in nature, but we can form the
convex split such that the left-hand side is fully linear, e.g., <span class="math notranslate nohighlight">\(g_+(\phi) = a
\phi^2\)</span> for <span class="math notranslate nohighlight">\(g(\phi) = \phi^2 (1-\phi)^2\)</span>.  As a result, we need a linear
solver for this scheme (such as a tridiagonal LU decomposition) to obtain
<span class="math notranslate nohighlight">\(\{\phi^{n+1}\}\)</span>, but no nonlinear solver.  We can use larger time step sizes
than with Forward Euler, but we can easily “break” the system so that we don’t
observe a monotonic decrease in free energy.</p>
<p>Lastly, we may choose to discretize this system by the Backward Euler method:</p>
<div class="math notranslate nohighlight">
\[
\phi_i^{n+1} - \Delta t (\phi_{i+1}^{n+1} - 2\phi_i^{n+1} + \phi_{i-1}^{n+1} - g'(\phi_i^{n+1}) - Qp'(\phi_i^{n+1})  = \phi_i^n
\]</div>
<p>The left-hand side is now fully implicit and nonlinear. We will need to perform
a nonlinear solve at each time step, and this may or may not require the
solution of additional linear systems.</p>
</section>
<section id="types-of-nonlinear-solvers">
<h4>Types of Nonlinear Solvers<a class="headerlink" href="#types-of-nonlinear-solvers" title="Link to this heading">#</a></h4>
<p>Two of the most common types of nonlinear methods you will encounter are
<strong>fixed-point methods</strong>, which solve problems of the form <span class="math notranslate nohighlight">\(G(u) = u\)</span>, and
<strong>root finding methods</strong>, which solve problems of the form <span class="math notranslate nohighlight">\(F(u) = 0\)</span>.  We can
usually convert fixed-point problems to root-finding problems by letting <span class="math notranslate nohighlight">\(F(u)
= G(u) - u\)</span>, but the reverse conversion may not be as well-behaved and will be
problem dependent.  These methods have some similarities in underlying
concepts, but the resulting algorithms and implementation can vastly differ.</p>
<p>While not discussed here, another important class of nonlinear methods is Full
Approximation Scheme (FAS) multigrid solvers.  In FAS, we obtain solutions of
the system <span class="math notranslate nohighlight">\(A(u) = f\)</span> by relaxing the residual and its error on progressively
coarsened grids, after which we interpolate a set of corrections onto the finer
grid levels.  Depending on the forms of <span class="math notranslate nohighlight">\(A(u)\)</span> and <span class="math notranslate nohighlight">\(f\)</span>, this method can look
like a fixed-point or root-finding method that can be applied to a wide range
of systems, although the implementation can be quite complex.</p>
<p><strong>Fixed-Point Methods:</strong> A basic fixed-point method will often adopt the
following approach:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, compute the nonlinear function, <span class="math notranslate nohighlight">\(G(u)\)</span></p></li>
<li><p>Calculate a new guess by <span class="math notranslate nohighlight">\(\tilde{u} = G(u)\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||u - \tilde{u}|| &lt; tol\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>This is often referred to as functional iteration or Picard iteration.  <strong>While
simple to implement, this basic scheme may converge slowly or fail to converge
at all.</strong>  There are schemes to accelerate the convergence of the series (e.g.,
Anderson Mixing, Aitken’s Delta-Squared Method), or we can linearize the
nonlinear function about <span class="math notranslate nohighlight">\(\tilde{u}\)</span> as <span class="math notranslate nohighlight">\(G(\tilde{u}) \approx G(u) + \mathbf{J}
(\tilde{u} - u)\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{J} = \nabla G(u)\)</span> is the Jacobian matrix of
the nonlinear system.  The resulting <strong>linearized fixed-point method</strong> is then
of the form:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, compute the nonlinear function, <span class="math notranslate nohighlight">\(G(u)\)</span></p></li>
<li><p>Solve the linear system <span class="math notranslate nohighlight">\((\mathbf{I} - \mathbf{J})\tilde{u} = G(u) - \mathbf{J}u\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||u - \tilde{u}|| &lt; tol\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>As a note, we may not need to explicitly assemble <span class="math notranslate nohighlight">\(\mathbf{J}\)</span>, or the
associated linear solver in step (2) might arise “naturally” in the governing
equations.  For example, a pointwise Jacobi-type fixed-point iteration for the
fully-implicit 1D Allen-Cahn example can be written as</p>
<div class="math notranslate nohighlight">
\[
\tilde{\phi_i}^{n+1} = \frac{\phi_i^n + \Delta t (\phi_{i+1}^{n+1} + \phi_{i-1}^{n+1} - g'(\phi_i^{n+1}) + g''(\phi_i^{n+1})\phi_i^{n+1} - Q p'(\phi_i^{n+1}) + Q p''(\phi_i^{n+1}) \phi_i^{n+1} )}{1 + 2 \Delta t + \Delta t ( g''(\phi_i^{n+1}) + Q p''(\phi_i^{n+1}) )}
\]</div>
<p>where <span class="math notranslate nohighlight">\(g''\)</span> and <span class="math notranslate nohighlight">\(p''\)</span> are second derivatives of the respective functions. This
combines steps (1) and (2) into a single process as we sweep over the entire
mesh to evaluate <span class="math notranslate nohighlight">\(\{\tilde{\phi}^{n+1}\}\)</span>.</p>
<p><strong>Root-Finding Methods:</strong> In many cases, a root-finding method will often adopt
some sort of Newton-type method where we linearize the function through a
Taylor expansion, obtain a correction to the solution, and then iterate until
convergence.  For example, the classic <strong>Newton-Raphson method</strong> can be written
as:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, calculate <span class="math notranslate nohighlight">\(F(u)\)</span> and its Jacobian matrix <span class="math notranslate nohighlight">\(\mathbf{J}\)</span></p></li>
<li><p>Correct the solution by solving the linear system <span class="math notranslate nohighlight">\(\delta u = - \mathbf{J}^{-1} F(u)\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||\delta u|| &lt; tol\)</span></p></li>
<li><p>Assemble the next guess as <span class="math notranslate nohighlight">\(\tilde{u} = u + \delta u\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>Immediately, we can recognize a similarity between the Newton-Raphson approach
and the linearized fixed-point iteration: both perform a linearization about
the current value of the function for a guess of <span class="math notranslate nohighlight">\(u\)</span> and solve a linear system
to obtain the next guess.  (Note: this is part of why we say that fixed-point
solutions can be obtained through an equivalent root-finding method.)</p>
<p>Assembling <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> and solving the linear system for <span class="math notranslate nohighlight">\(\delta u\)</span> can be
exceptionally expensive. However, if <em>iterative linear solvers</em> are employed,
a few iterations of the linear method can significantly reduce the residual of
the nonlinear system.  This leads to the formation of an <strong>inexact Newton
method</strong>:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, calculate <span class="math notranslate nohighlight">\(F(u)\)</span> and its Jacobian matrix
<span class="math notranslate nohighlight">\(\mathbf{J}\)</span></p></li>
<li><p>Perform <span class="math notranslate nohighlight">\(k\)</span> iterations of an iterative linear solver to approximately solve
<span class="math notranslate nohighlight">\(\mathbf{J} \delta u = - F(u)\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||\delta u|| &lt; tol\)</span></p></li>
<li><p>Assemble the next guess as <span class="math notranslate nohighlight">\(\tilde{u} = u + \delta u\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>We may make further modifications to this algorithm to potentially improve
performance, such as only evaluating <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> every few iterations. If we
employ Krylov methods for step (2), we do not necessarily need to form the
Jacobian and instead only need to evaluate matrix-vector products <span class="math notranslate nohighlight">\(\mathbf{J}
\delta u\)</span>. This leads to the popular and powerful <strong>Jacobian-Free Newton-Krylov
(JFNK) method</strong>, which is employed by many community codes and software
libraries.  Also common are <strong>Newton-Multigrid methods</strong>, where a few multigrid
iterations are performed in step (2).  We may further try to “globalize” the
solution by combining the inexact Newton method with a line-search method to
find an optimal decrease in the residual, usually under the condition <span class="math notranslate nohighlight">\(||F(u +
\alpha \delta u)|| &lt; ||F(u)||\)</span> with <span class="math notranslate nohighlight">\(\alpha\)</span> between 0 and 1.</p>
<p>If we examine the pointwise Jacobi scheme for the fully-implicit Allen-Cahn, we
see that this is essentially an inexact Newton method that does one inner
iteration of Jacobi relaxation at each outer Newton iteration.  Thus, we can
see that there are some general similarities between these broad classes of
nonlinear methods.  <strong>However, it is rare that the resulting algorithms are
exactly equivalent to each other, and it can be nontrivial to switch from a
fixed-point to a root-finding solver.</strong></p>
</section>
<section id="types-of-linear-solvers">
<h4>Types of Linear Solvers<a class="headerlink" href="#types-of-linear-solvers" title="Link to this heading">#</a></h4>
<p>In the above discussion, we’ve observed that linear solvers are necessary as a
result of the discretization of the governing equations or because we need to
solve a nonlinear system of equations. <strong>The choice of solver will depend on
the size of your simulation and whether you can easily evaluate a Jacobian
matrix of your system.</strong>  Up to a few thousand unknowns, direct linear solvers
(e.g. LAPACK, UMFPACK, cuSolver, SuperLU) that offer dense or sparse variants
of typical methods like LU decomposition and QR factorization will often be
efficient, provided it is easy to evaluate the entries of the Jacobian matrix.
However, it is important to remember that dense direct solvers typically scale
O(n^2) for required memory and O(n^3) for the number of operations and quickly
become unsolvable.  The scalability of sparse direct solvers will depend on the
particular method and the implementing library.  For millions or billions of
unknowns across large numbers of CPUs or GPUs, iterative solvers are often
necessary.  Here, a wide range of options exists; in particular, relaxation,
multigrid, and Krylov methods all parallelize well and have been employed in a
variety of community codes and numerical libraries.</p>
<p>Some of the simplest iterative methods are stationary relaxation methods such
as the Jacobi, Gauss-Seidel, and (Symmetric) Successive Over-Relaxation
methods.  Classically, these are derived by splitting the Jacobian matrix as <span class="math notranslate nohighlight">\(J
= D - E - F\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> is the diagonal, <span class="math notranslate nohighlight">\(-E\)</span> is the purely lower triangular
portion, and <span class="math notranslate nohighlight">\(-F\)</span> is the purely upper triangular portion.  Depending on how we
manipulate <span class="math notranslate nohighlight">\(D\)</span>, <span class="math notranslate nohighlight">\(E\)</span>, and <span class="math notranslate nohighlight">\(F\)</span>, we obtain the above methods or their symmetric
variants; however, <strong>we may not need to directly form the Jacobian or its
submatrices</strong>, as we observed in the above Allen-Cahn example.  <strong>The
simplicity and low memory requirements of relaxation methods make them
attractive methods, but they often converge slowly.</strong>  The convergence can be
improved by employing multigrid methods: <strong>Geometric Multigrid methods converge
rapidly by applying relaxation methods</strong> on multiple levels of structured grids
and are popular solvers for a wide range of problems.</p>
<p>Krylov methods (e.g. Conjugate Gradient, GMRES, BiCGSTAB, TFQMR) are a powerful
family of linear solvers that form a subspace from a linear operator (such as
the Jacobian) and the residual vectors of the system (this is a very simplified
explanation). While these methods can be formulated to directly use the
Jacobian, <strong>most only require the evaluation of Jacobian-vector products</strong>,
which is what leads to the “Jacobian-free” nature of JFNK methods.  This
Jacobian-vector product is typically evaluated in either a functional form if
the Jacobian can be easily obtained (e.g., the kernel of a linear heat
equation), but for methods such as JFNK, <strong>the Jacobian-vector product is
readily approximated by the Gateaux derivative</strong>.  These methods can,
therefore, be <strong>straightforward to implement, even with intricate linear
functions</strong>.  However, <strong>convergence is strongly dependent on the condition
number of the operator matrix.</strong></p>
<p>The performance of Krylov methods can be improved through <strong>preconditioning</strong>.
Here, we form an approximation to the overall Jacobian matrix, <span class="math notranslate nohighlight">\(\mathbf{M}
\approx \mathbf{J}\)</span>.  Depending on the exact method, we will then find
solutions to some linear system of the residual, e.g., <span class="math notranslate nohighlight">\(\mathbf{M} z = r\)</span>, at
certain points of the algorithm.  If done correctly, the computational time and
the number of iterations to reach the desired tolerance will decrease.  The
preconditioner, therefore, needs to (1) be easy to form and assemble, (2) be
easy to solve and apply, and (3) should capture the essential physics of the
system.  <strong>Designing preconditioners is problem-dependent and can have a huge
impact on the overall model performance</strong>.  Many possible options have been
applied by the phase-field community, including relaxation methods (e.g.,
Jacobi, Gauss-Seidel), multigrid methods (both geometric and algebraic),
incomplete LU and Cholesky factorizations, sparse approximate inverses, and
multiplicative or additive Schwarz methods.  <strong>You will likely need to
experiment with the best preconditioner for your model,</strong> which can require a
significant amount of time if your libraries don’t already provide them.</p>
<p>In summary: when choosing linear solvers, <strong>it is not trivial to switch from a
relaxation or multigrid method to a Krylov method (or vice versa)</strong>, although
the former methods can be used as preconditioners for the latter.  Changing
from one Krylov method to another can be relatively straightforward, but <strong>some
Krylov methods only apply to symmetric positive definite matrices</strong>.  Modifying
the preconditioner can have varying difficulties: switching from a Jacobi to a
Gauss-Seidel preconditioner is trivial, but switching to an ILU preconditioner
might require much more effort.</p>
</section>
</section>
<section id="choosing-an-appropriate-parallelism-approach">
<h3>Choosing an appropriate parallelism approach<a class="headerlink" href="#choosing-an-appropriate-parallelism-approach" title="Link to this heading">#</a></h3>
<p>(Discuss distributed vs shared, CPU vs GPU)</p>
<section id="distributed-memory">
<h4>Distributed memory<a class="headerlink" href="#distributed-memory" title="Link to this heading">#</a></h4>
<p>(pretty much just MPI, also mention UPC or Legion or Charm++?)</p>
</section>
<section id="shared-memory">
<h4>Shared memory<a class="headerlink" href="#shared-memory" title="Link to this heading">#</a></h4>
<p>CPU/GPU, performance portability layers</p>
</section>
</section>
</section>
<section id="choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself">
<h2>Choosing appropriate numerical libraries and/or what to write yourself<a class="headerlink" href="#choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself" title="Link to this heading">#</a></h2>
<p>The phase-field and broader scientific computing community have developed many
libraries that you may choose to use as you implement your phase-field
model. As you decide which methods you want to use, an important consideration
is whether you intend to write code for certain functionality yourself or
whether you want to use an existing library/framework for that functionality.</p>
<section id="investigate-existing-solutions-before-writing-your-own">
<h3>Investigate existing solutions before writing your own<a class="headerlink" href="#investigate-existing-solutions-before-writing-your-own" title="Link to this heading">#</a></h3>
<p>Before coding your own functionality, it is always a good idea to explore what
solutions already exist. Researchers have devoted their careers to developing
some scientific computing libraries and frameworks, and they may be better for
your application than something you write yourself. Even in the cases where you
<em>could</em> write code for some functionality yourself that is an improvement over
existing solutions, it may not be worth your time to actually do so. Finally,
even if you decide that your best course is to write your own functionality,
learning about other solutions may inform your approach and/or help you frame
to potential users what distinguishes your implementation.</p>
<section id="existing-phase-field-codes-and-frameworks">
<h4>Existing phase-field codes and frameworks<a class="headerlink" href="#existing-phase-field-codes-and-frameworks" title="Link to this heading">#</a></h4>
<p>PFHub maintains a <a class="reference external" href="https://pages.nist.gov/pfhub/codes/">list of open source phase-field codes and
frameworks</a>, one or more of which may fit
your needs.</p>
</section>
<section id="consider-how-existing-libraries-interact">
<h4>Consider how existing libraries interact<a class="headerlink" href="#consider-how-existing-libraries-interact" title="Link to this heading">#</a></h4>
<p>Some libraries are packages in a larger collection where interfaces for
interoperability have already been developed. Such large collections include
<a class="reference external" href="https://trilinos.github.io/">Trilinos</a>, <a class="reference external" href="https://petsc.org/release/">PETSc</a>,
and
<a class="reference external" href="https://github.com/hypre-space/hypre">hypre</a>/<a class="reference external" href="https://github.com/LLNL/SAMRAI">SAMRAI</a>/<a class="reference external" href="https://sundials.readthedocs.io/en/latest/">SUNDIALS</a>. Staying
within an ecosystem may reduce your time to solution and will keep you on a
well-traveled path if you reach out to developers or a user community for help.</p>
</section>
<section id="consider-local-expertise">
<h4>Consider local expertise<a class="headerlink" href="#consider-local-expertise" title="Link to this heading">#</a></h4>
<p>An important consideration for choosing a library or framework is who else uses
it. If many other researchers in your organization use a particular
library/framework, you may want to as well – when you run into issues, they
might be able to help you (and vice versa).</p>
</section>
</section>
<section id="consider-licensing">
<h3>Consider licensing<a class="headerlink" href="#consider-licensing" title="Link to this heading">#</a></h3>
<p>Another consideration for choosing a library or framework is what the license
terms are. For commercial software, license terms may dictate that a new
license must be bought for each CPU core being used. With paid software, you
may also want to consider the future of your work, even if you have access to
that software now, that may not be true if you move institutions, your
institution changes what they buy, etc. Other people who would be interested in
using code that you develop would also have to pay for the underlying software.</p>
<p>For open-source libraries and frameworks, a wide variety of open-source
licenses exist. While a discussion of the differences between these licenses is
out of the scope of this document, the details of the license may constrain how
you can use the library/framework and how you can distribute derivative
works. One reference for open-source licenses is the <a class="reference external" href="https://opensource.org/licenses">Open Source
Initiative</a>. The terms of these licenses can
be confusing and disputed. The legal department at your institution may be able
to offer advice.</p>
</section>
</section>
<section id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Link to this heading">#</a></h2>
<section id="solver-methods">
<h3>Solver Methods:<a class="headerlink" href="#solver-methods" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Y. Saad. <em>Iterative Methods for Sparse Linear Systems, Second Edition.</em>
Society for Industrial and Applied Mechanics, 2003.</p></li>
<li><p>W.L. Briggs, V. Emden Henson, S.F. McCormick. <em>A Multigrid Tutorial, Second
Edition.</em> Society for Industrial and Applied Mechanics, 2000.</p></li>
<li><p>D.A. Knoll, D.E. Keyes. “Jacobian-free Newton-Krylov methods: a survey of
approaches and applications.” <em>J. Comput. Phys.</em> 193 (2004) 357-397.</p></li>
</ol>
<hr class="docutils" />
<p>Topics we want to move to other sections:</p>
<ul class="simple">
<li><p>Conservation laws and symmetries (Model Formulation)</p></li>
<li><p>Have an expectation going in (Model Formulation)</p></li>
<li><p>Add pieces of the model one part at a time during debugging (Software Development)</p></li>
<li><p>Ensure physical expectations are respected (Software Development)</p></li>
</ul>
<hr class="docutils" />
<!--
OLD TEXT

Contributors: Stephen DeWitt, Alex Chadwick

Alex Chadwick, Steve Dewitt

* Carefully consider your spatial discretization scheme (FFT, FD, FV, FEM)
* Consider your temporal discretization scheme and use temporal error
  estimation when possible (implicit, explicit, etc.)
* Identify relevant conservation laws and symmetries for your model and
  carefully ensure they are respected even after long times
* Start small and add complexity. Add pieces to the model one part at a time
  during debugging. Check to see if it is working, then add more, then test
  again.
* Have an expectation going in (back of the envelope, consider basic physics),
  and if it doesn’t do that, figure out why.
-->
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./bp-guide-gh"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ch1-model-formulation.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Model Formulation</p>
      </div>
    </a>
    <a class="right-next"
       href="ch3-data-generation-and-curation.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Data Generation and Curation</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-collection-of-numerical-methods">Choosing an appropriate collection of numerical methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#start-simple-then-selectively-move-to-more-complex-methods">Start simple, then selectively move to more complex methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-spatial-discretization">Choosing a spatial discretization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-difference">Finite difference</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-volume">Finite volume</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-element">Finite element</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fourier-pseudospectral">Fourier pseudospectral</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-discretization-summary-table">Spatial Discretization Summary Table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#adaptive-mesh-refinement">Adaptive Mesh Refinement</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#methods-for-applying-boundary-conditions-on-internal-boundaries">Methods for Applying Boundary Conditions on Internal Boundaries</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-time-integration-method">Choosing a Time Integration Method</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#explicit-vs-implicit-methods">Explicit vs. Implicit Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity">Complexity</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#time-step-cost-and-size">Time step cost and size</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-usage">Memory usage</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coupling-and-consistency">Coupling and Consistency</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#semi-implicit-and-imex-methods">Semi-Implicit and ImEx Methods</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#time-step-adaptivity">Time Step Adaptivity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-guidelines">General Guidelines</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-linear-and-nonlinear-solvers-if-needed">Choosing Linear and Nonlinear Solvers (If Needed)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#when-you-might-need-linear-or-nonlinear-solvers">When You Might Need Linear or Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-nonlinear-solvers">Types of Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-linear-solvers">Types of Linear Solvers</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-parallelism-approach">Choosing an appropriate parallelism approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#distributed-memory">Distributed memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#shared-memory">Shared memory</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself">Choosing appropriate numerical libraries and/or what to write yourself</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#investigate-existing-solutions-before-writing-your-own">Investigate existing solutions before writing your own</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#existing-phase-field-codes-and-frameworks">Existing phase-field codes and frameworks</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-how-existing-libraries-interact">Consider how existing libraries interact</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-local-expertise">Consider local expertise</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-licensing">Consider licensing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further reading</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solver-methods">Solver Methods:</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By PFHub Workshop Community
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>