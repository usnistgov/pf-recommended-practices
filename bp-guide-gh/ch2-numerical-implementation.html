
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Numerical Implementation &#8212; Phase Field Method Recommended Practices</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'bp-guide-gh/ch2-numerical-implementation';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Generation and Curation" href="ch3-data-generation-and-curation.html" />
    <link rel="prev" title="Model Formulation" href="ch1-model-formulation.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/pfhub-logo.jpg" class="logo__image only-light" alt="Phase Field Method Recommended Practices - Home"/>
    <img src="../_static/pfhub-logo.jpg" class="logo__image only-dark pst-js-only" alt="Phase Field Method Recommended Practices - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Phase Field Method Recommended Practices
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Importing GH Wiki</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ch1-model-formulation.html">Model Formulation</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Numerical Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3-data-generation-and-curation.html">Data Generation and Curation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4-software-development.html">Software Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5-problem-setup.html">Problem Set-Up</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch6-result-dissemination.html">Result Dissemination</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Default Pages</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../defaults/markdown.html">Markdown Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../defaults/markdown-notebooks.html">Notebooks with MyST Markdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="../defaults/notebooks.html">Content with notebooks</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/usnistgov/pf-recommended-practices" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/usnistgov/pf-recommended-practices/issues/new?title=Issue%20on%20page%20%2Fbp-guide-gh/ch2-numerical-implementation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/bp-guide-gh/ch2-numerical-implementation.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Numerical Implementation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-collection-of-numerical-methods">Choosing an appropriate collection of numerical methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#start-simple-then-selectively-move-to-more-complex-methods">Start simple, then selectively move to more complex methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-spatial-discretization">Choosing a spatial discretization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-difference">Finite difference</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-volume">Finite volume</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-element">Finite element</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fourier-pseudospectral">Fourier pseudospectral</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-discretization-summary-table">Spatial Discretization Summary Table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#adaptive-mesh-refinement">Adaptive Mesh Refinement</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#methods-for-applying-boundary-conditions-on-internal-boundaries">Methods for Applying Boundary Conditions on Internal Boundaries</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-time-integration-method">Choosing a Time Integration Method</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#explicit-vs-implicit-methods">Explicit vs. Implicit Methods</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coupling-and-consistency">Coupling and Consistency</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#semi-implicit-and-imex-methods">Semi-Implicit and ImEx Methods</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#time-step-adaptivity">Time Step Adaptivity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-guidelines">General Guidelines</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-linear-and-nonlinear-solvers-if-needed">Choosing Linear and Nonlinear Solvers (If Needed)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#when-you-might-need-linear-or-nonlinear-solvers">When You Might Need Linear or Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-nonlinear-solvers">Types of Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-linear-solvers">Types of Linear Solvers</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-parallelism-approach">Choosing an appropriate parallelism approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#distributed-memory">Distributed memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#shared-memory">Shared memory</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself">Choosing appropriate numerical libraries and/or what to write yourself</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#investigate-existing-solutions-before-writing-your-own">Investigate existing solutions before writing your own</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#existing-phase-field-codes-and-frameworks">Existing phase-field codes and frameworks</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-how-existing-libraries-interact">Consider how existing libraries interact</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-local-expertise">Consider local expertise</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-licensing">Consider licensing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further reading</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solver-methods">Solver Methods:</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="numerical-implementation">
<h1>Numerical Implementation<a class="headerlink" href="#numerical-implementation" title="Link to this heading">#</a></h1>
<p>When writing your own phase-field simulation code or when choosing among existing codes, the numerical implementation of the model is an important consideration. This section of Phase-Field Recommended Practices Guide is split into two subsections – one focused on choosing appropriate numerical methods and one focused on choosing whether to code your own solvers or use existing libraries (and how to choose between existing libraries). Although these subsections are presented sequentially, these choices are more iterative than sequential. For example, you may start out deciding that a certain set of numerical methods are promising, but then switch to others after considering the availability of libraries.</p>
<section id="choosing-an-appropriate-collection-of-numerical-methods">
<h2>Choosing an appropriate collection of numerical methods<a class="headerlink" href="#choosing-an-appropriate-collection-of-numerical-methods" title="Link to this heading">#</a></h2>
<p>There is no consensus on what the “best” numerical methods for phase-field modeling are. In fact, given the diversity of the models and settings under the phase field umbrella, it is unlikely that any single collection of methods would be optimal for all phase-field modeling. Instead, a wide variety of numerical methods are used in the literature. For most problems of interest there are multiple numerical methods that can be used to obtain a solution to the model equations (and perhaps some methods that <em>cannot</em> obtain a solution). Several factors to consider when choosing between numerical methods are:</p>
<ul class="simple">
<li><p>General computational performance</p></li>
<li><p>Appropriateness for the planned computing hardware (e.g., GPUs)</p></li>
<li><p>Scalability, ease of implementation</p></li>
<li><p>Availability of libraries</p></li>
</ul>
<p>Each researcher may have their own unique balance of these factors that leads them to choose a numerical approach.</p>
<p>These choices can be very important. The performance of different methods for a given problem can vary by orders of magnitude. Likewise the complexity to implement the methods can vary by orders of magnitude – some solvers can be written in a few tens of lines of code; some may take tens of thousands of lines. The path-dependency of the choices are also variable. Transitioning from a spectral code to a finite element code might necessitate an entire rewrite. Transitioning from one implicit time integration method to another may take a few hours.</p>
<p>A phase-field code involves a few different types of numerical methods. Different choices for each type are possible, but not all combinations are possible or advisable. In the end, to determine the numerical implementation for your phase-field model you will need to decide on a collection of numerical methods and approaches that are suitable for your problem and work well together.</p>
<p>Before deciding on a strategy for a numerical implementation, we strongly recommend that you put thought into your problem(s) of interest. Understanding the governing equations, boundary conditions, initial conditions, coupled physics, expected symmetries and other factors discussed in the <a class="reference external" href="https://github.com/usnistgov/pfhub/wiki/Model-Formulation">Model Formulation section</a> will aid you in deciding on how to implement your model numerically.</p>
<section id="start-simple-then-selectively-move-to-more-complex-methods">
<h3>Start simple, then selectively move to more complex methods<a class="headerlink" href="#start-simple-then-selectively-move-to-more-complex-methods" title="Link to this heading">#</a></h3>
<p>In general, we recommend that you start with a simple method and then add complexity selectively where justified. There are a few benefits to this approach.</p>
<ol class="arabic simple">
<li><p>Simpler methods are usually easier to implement, decreasing the time from starting to running your first test simulation. This gives you an earlier opportunity to identify unexpected issues in your model formulation that you didn’t catch before implementing it. Part of what makes a simpler method easier to implement is that a simpler method is often easier to debug and/or there are fewer ways for it to fail.</p></li>
<li><p>The simpler implementation can be a backup option if the development of a more complex option takes longer than expected. Even following the <a class="reference external" href="https://github.com/usnistgov/pfhub/wiki/Software-Development">recommended practices for software development</a>, code development times can be unpredictable. A suboptimal backup implementation might get you through your first milestones while you’re debugging a more advanced method.</p></li>
<li><p>You may learn that the simpler option fulfills your needs. Complex methods aren’t always better; the problem of interest might not need or justify investment in more complex methods.</p></li>
<li><p>Even if the simpler method doesn’t fulfill your needs, it may illuminate where added complexity is worth investigating (“these small explicit time steps are bogging me down, I should try an implicit time integrator”, “I’m wasting so many resources in this area where nothing happens, I should try adaptive meshing”).</p></li>
<li><p>Solutions obtained with the simpler method can be used as reference solutions as part of your <a class="reference external" href="https://github.com/usnistgov/pfhub/wiki/Software-Development">code verification strategy</a>. Obtaining the same solution with two methods is no guarantee that both are correct, but it is an encouraging sign. And certainly, if two methods yield different solutions, the implementations require attention.</p></li>
</ol>
<p>This all said, there may be some compelling reasons to start with more complex methods. One such reason is if the method is already implemented in an off-the-shelf package. Other numerical considerations could come into play: an unpreconditioned Krylov solver is <em>simpler</em> than a preconditioned one, but the preconditioner stabilizes the solution and may be more forgiving for non-optimized simulation parameters in an initial exploratory phase for a project and may be <em>simpler to use</em>.</p>
<p>Additionally, we also recommend initially implementing a simpler form of your model and the building up to the full model, particularly if you are new to the toolchain that you’re using. There are classes of issues that with your numerical implementation that show up in even very simple calculations (MPI communication issues, stencil issues, scaling issues, etc.), and it’s best to deal with those as soon as possible. Note: this approach works best when the simplified model is a simplified version of the <em>PDE</em>, not simply a simplified version of the <em>physics</em>. Sometimes models at different levels of complexity have a very different structure. A few examples of simpler starting models are:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Target Model</p></th>
<th class="head text-center"><p>Simplified Variant</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>BM1 (Cahn-Hilliard)</p></td>
<td class="text-center"><p>Diffusion equation, then add the higher order term</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>BM2 (Coupled Cahn-Hilliard-Allen-Cahn)</p></td>
<td class="text-center"><p>Cahn-Hilliard by itself, add one Allen-Cahn equation, then two, then all of them</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>BM4 (Elastic Precipitate)</p></td>
<td class="text-center"><p>Cahn-Hilliard by itself, then add elasticity</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="choosing-a-spatial-discretization">
<h3>Choosing a spatial discretization<a class="headerlink" href="#choosing-a-spatial-discretization" title="Link to this heading">#</a></h3>
<p>Four main types of spatial discretizations are used for phase-field modeling: finite difference, finite volume, finite element, and Fourier pseudospectral. Each of these methods has been used for simulation results uploaded to PFHub. Examples for each method are: finite difference - <a class="reference external" href="https://github.com/memphis-snl/memphis">Memphis</a>, <a class="reference external" href="https://github.com/usnistgov/HiPerC">HiPerC</a>, finite volume - <a class="reference external" href="https://github.com/usnistgov/fipy">FiPy</a>, finite element - <a class="reference external" href="https://github.com/idaholab/moose">MOOSE</a>, <a class="reference external" href="https://github.com/prisms-center/phaseField">PRISMS-PF</a>, <a class="reference external" href="https://github.com/FEniCS">Fenics</a>, Fourier pseudospectral - <a class="reference external" href="https://code.ornl.gov/meumapps/meumapps">MEUMAPPS</a>).</p>
<p>Here we give a brief overview of the strengths and weaknesses of each of these spatial discretization approaches. Aiming for brevity over completeness, this discussion skips over the considerable nuance in the capabilities of these methods.</p>
<section id="finite-difference">
<h4>Finite difference<a class="headerlink" href="#finite-difference" title="Link to this heading">#</a></h4>
<p>Finite difference discretizations are one of the most common spatial discretizations for phase-field codes. The field data is stored on the vertices of the mesh and derivatives are approximated using variable values at the point of interest and/or neighboring points. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_difference_method">Wikipedia page</a> for a general introduction. While many flavors of finite difference methods exist, most finite difference phase-field codes use structured, uniform grids.</p>
</section>
<section id="finite-volume">
<h4>Finite volume<a class="headerlink" href="#finite-volume" title="Link to this heading">#</a></h4>
<p>With finite volume methods, the field data is stored for each element in the mesh (i.e., the “finite volume”), and changes to the field data are calculated by summing the fluxes through the faces of the element. Therefore, finite-volume methods are inherently conservative. Because the flux calculations are done on the faces, finite volume methods can be used on unstructured meshes. Also, as a result of the emphasis on fluxes, finite volume methods solve the weak form of a PDE. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_volume_method">Wikipedia page</a> for a general introduction.</p>
</section>
<section id="finite-element">
<h4>Finite element<a class="headerlink" href="#finite-element" title="Link to this heading">#</a></h4>
<p>Finite element methods are the most complex of the common spatial discretization methods for phase-field codes. In a finite element method, field values are stored on pre-defined places of each element (the “nodes”). The field variables in the element are continuously represented by a function of pre-defined type (e.g., bilinear) that passes through the field values at each node (the “shape function”). Derivatives are calculated through derivatives of the shape function. The field variables are evolved using volumetric integrals over the element, where the integrals are calculated using <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_quadrature">quadrature</a>. Therefore, although field variables are stored at the nodes for the element, the evolution expressions are calculated on “quadrature points”, which often are not in the same locations as the nodes. Due to the expressions being integral expressions, finite element methods operate on the weak form of a PDE. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_element_method">Wikipedia page</a> for a general introduction.</p>
</section>
<section id="fourier-pseudospectral">
<h4>Fourier pseudospectral<a class="headerlink" href="#fourier-pseudospectral" title="Link to this heading">#</a></h4>
<p>Along with finite difference methods, Fourier pseudospectral methods are historically a common spatial discretization for phase-field codes. Although Fourier pseudospectral methods have similar theoretical underpinnings as finite element methods, in practice, implementing a Fourier pseudospectral code is very different from the other methods listed here. In comparison to the other methods with a local representation of the fields, the Fourier pseudospectral method has a global representation of the fields using sines and cosines. As a result, derivatives of fields can be calculated using fast Fourier transforms (FFTs); in the reciprocal space, a spatial derivative becomes a multiplication with a wavenumber. This FFT-centric approach avoids the need for linear solvers that the other spatial discretization may need, leading to a popular semi-implicit time integration scheme (see below for more details). Fourier pseudospectral methods have the fastest spatial convergence of any scheme here, exponential convergence (as compared to polynomial convergence for the other methods). To balance these advantages, Fourier pseudospectral methods have restrictions that the other methods do not. The reliance on FFTs means that periodic boundary conditions are the only type of boundary conditions possible. The FFTs also require a uniform, structured mesh, so no adaptive meshing is possible in most situations (e.g., unless a coordinate tranformation is possible to project onto a uniform, structured mesh).</p>
</section>
<section id="spatial-discretization-summary-table">
<h4>Spatial Discretization Summary Table<a class="headerlink" href="#spatial-discretization-summary-table" title="Link to this heading">#</a></h4>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head text-center"><p>Strengths</p></th>
<th class="head text-center"><p>Weaknesses</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Finite difference</strong></p></td>
<td class="text-center"><p>Simple to code <br/> Minimal computational overhead <br/> Adaptive meshing is possible</p></td>
<td class="text-center"><p>Conservation is not guaranteed depending on the stencil <br/> Difficult to use on complex geometries (more complicated on non-uniform grids and much more complicated (impossible?) on unstructured grids) <br/> Adaptive meshing is constrained by need for a structured mesh</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Finite volume</strong></p></td>
<td class="text-center"><p>Naturally conservative <br/> Adaptive meshing is possible <br/> Can be used for arbitrary geometries (via unstructured meshes) <br/> Simpler to implement than finite element methods</p></td>
<td class="text-center"><p>More complicated to implement than finite difference or Fourier-pseudospectral <br/> Orders of accuracy higher than two substantially increase complexity</p></td>
</tr>
<tr class="row-even"><td><p><strong>Finite element</strong></p></td>
<td class="text-center"><p>Adaptive meshing is possible <br/> Can be used for arbitrary geometries (via unstructured meshes) <br/> Fairly straightforward extension to higher orders of accuracy <br/> Popularity in other domains may aid multiphysics coupling</p></td>
<td class="text-center"><p>Most complicated to code <br/> Most computational overhead</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Fourier pseudospectral</strong></p></td>
<td class="text-center"><p>Simple to code <br/> Highest spatial error convergence rate <br/> “Free” implicit handling of linear terms</p></td>
<td class="text-center"><p>Limited to periodic boundary conditions <br/> Limited to uniform, structured meshes</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="adaptive-mesh-refinement">
<h4>Adaptive Mesh Refinement<a class="headerlink" href="#adaptive-mesh-refinement" title="Link to this heading">#</a></h4>
<p>Adaptive mesh refinement (AMR) is the process of changing the mesh for a calculation so that the mesh is finer in regions where the spatial error is expected to be high (e.g., where fields are changing rapidly) and coarser where the spatial error is expected to be low (e.g., where fields are changing slowly). An example of adaptive mesh refinement for the PFHub Benchmark 3 problem is shown below:</p>
<p>(Insert BM3 AMR example)</p>
<p>Note that in this example, the mesh is the finest near the solid-liquid interface and coarsest far from the interface in the liquid. PFHub Benchmark 3 is an example of a problem where adaptive meshing is particularly useful – at any given time, the area of the interfacial region is a small fraction of the total area. The interfacial region needs a fine mesh to resolve the transition of the order parameter, but a coarse mesh can be used far into the liquid where only thermal diffusion is active. The <a class="reference external" href="https://pages.nist.gov/pfhub/simulations/3a.1/">uploaded results</a> with by far the fastest run times for this simulations, using MOOSE and PRISMS-PF, both take advantage of adaptive meshing.</p>
<p>In other cases, the benefits of adaptive mesh refinement may not be worth the computation overhead and increase in complexity. The early stages of evolution for PFHub Benchmark 1 are an example of this case. The composition field is rapidly varying almost everywhere in the domain, and coarsening the mesh in any location would likely introduce substantial error.</p>
<p>Three main adaptive meshing schemes are:</p>
<ul class="simple">
<li><p>Adaptive unstructured meshes (full freedom of mesh shape, but high overhead)</p></li>
<li><p>Block-structured meshes (a mesh made of rectangular regions at different levels of refinement)</p></li>
<li><p>Quadtree/octree meshes (hierarchical mesh where refinement occurs by bisecting parent elements)</p></li>
</ul>
</section>
<section id="methods-for-applying-boundary-conditions-on-internal-boundaries">
<h4>Methods for Applying Boundary Conditions on Internal Boundaries<a class="headerlink" href="#methods-for-applying-boundary-conditions-on-internal-boundaries" title="Link to this heading">#</a></h4>
<p>Although many phase-field problems of interest can be solved in a rectangular domain with boundary conditions applied on the boundaries of the computational domain, in some cases, you may want to apply boundary conditions along an <em>internal</em> boundary. There are two typical circumstances where this occurs. One circumstance is where the domain of interest has some complex (perhaps dynamic) shape but you do not want to have a body-fitting mesh (e.g., due to code or method limitations). The second circumstance is that you are using a Fourier pseudospectral method and want to impose non-periodic boundary conditions.</p>
<p>Two methods have been developed to handle this issue – to impose boundary conditions internally in a computational domain that decouple the solution domain from the computational domain. The <a class="reference external" href="https://epubs.siam.org/doi/book/10.1137/1.9780898717464">immersed interface method</a> is a sharp-interface method for imposing internal boundary conditions. The <a class="reference external" href="https://doi.org/10.1088/0965-0393/20/7/075008">smoothed boundary method</a> is a diffuse interface method for imposing internal boundary conditions. In some circumstances, these methods may provide a performant way to side-step the restrictions on the meshes for Fourier pseudospectral or finite difference phase-field codes.</p>
<p>To date, none of the PFHub uploads have used these methods, but Benchmark 6b is an example of where it may be appropriate.</p>
</section>
</section>
<section id="choosing-a-time-integration-method">
<h3>Choosing a Time Integration Method<a class="headerlink" href="#choosing-a-time-integration-method" title="Link to this heading">#</a></h3>
<p>If your model is time dependent, you will need to choose a scheme for integrating in time (or time stepping).
A time integrator is typically described in terms of its order of accuracy and whether it is explicit or implicit.
Classic examples include:</p>
<ul class="simple">
<li><p>Forward Euler (FE) method, a first-order explicit method</p></li>
<li><p>Backward Euler (BE) method, a first-order implicit method</p></li>
<li><p>Crank-Nicolson (CN) method, a second-order semi-implicit method</p></li>
</ul>
<p>These methods often serve as prototypes for other families of general-purpose time integrators that have successfully been employed in phase-field codes.
<strong>Many of the community codes that participate in PFHub already offer selections of time integrators; the documentation of those packages will often include suggestions on what to choose for your model.</strong></p>
<p>If you are using a code that does not provide its own time integrators or you are writing your own code, there are many factors to consider when picking a scheme.
<strong>The “best” time integrator for your model will depend upon your governing equations, the spatial discretization, any required linear and nonlinear solvers, and even the computational hardware you have available.
You may need to experiment with different schemes to find the right balance of performance and accuracy for your needs.</strong>
This last step can require significant amounts of time and coding.</p>
<p>If you need to implement your own time integrator, we provide a brief overview of integration schemes and their strengths and weaknesses, but this discussion serves as a relatively high-level overview.
Time integration is an active area of research across the phase-field, applied math, and computational science communities, and it is impossible to cover every consideration.</p>
<section id="explicit-vs-implicit-methods">
<h4>Explicit vs. Implicit Methods<a class="headerlink" href="#explicit-vs-implicit-methods" title="Link to this heading">#</a></h4>
<p>In explicit methods, the solution at a future time step is only a function of previous time steps.
By comparison, for implicit methods, the solution at a future time step is a function of the future and previous time steps.
Forward Euler, for example, has the form <span class="math notranslate nohighlight">\((u^{n+1} - u^n) / \Delta t = f(u^n)\)</span>, and Backward Euler has the form <span class="math notranslate nohighlight">\((u^{n+1} - u^n) / \Delta t = f(u^{n+1})\)</span>.
Broadly, we can summarize the strengths (+) and weaknesses (-) as follows:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head text-center"><p>Explicit</p></th>
<th class="head text-center"><p>Implicit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Code complexity</p></td>
<td class="text-center"><p>+</p></td>
<td class="text-center"><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>Time step cost</p></td>
<td class="text-center"><p>+</p></td>
<td class="text-center"><p>-</p></td>
</tr>
<tr class="row-even"><td><p>Time step size</p></td>
<td class="text-center"><p>-</p></td>
<td class="text-center"><p>+</p></td>
</tr>
<tr class="row-odd"><td><p>Memory usage</p></td>
<td class="text-center"><p>+</p></td>
<td class="text-center"><p>-</p></td>
</tr>
</tbody>
</table>
</div>
<p>However, there are notable exceptions for each row.
Additionally, choices that influence each row of the above table also affect the overall consistency of a scheme.</p>
<p><strong>Complexity:</strong>
In general, explicit solvers do not require nonlinear solvers for the time-dependent portions of the model, and linear solvers are either not required (finite difference methods, many finite volume methods) or only require the inversion of the mass matrix (finite element methods).
This reduction in necessary solver components can reduce overall development time (less code, less debugging), which may allow you to start running simulations sooner.
Additionally, from a working FE code, it is straightforward to implement either explicit/embedded Runge-Kutta methods, Adams-Bashforth methods, or Predictor-Corrector (e.g., Milne) methods.</p>
<p>By comparison, fully implicit methods will usually require the implementation of nonlinear and linear solvers.
Some methods might allow for one of these eliminated: for example, the linearly implicit Rosenbrock Methods do not require a nonlinear solver.
However, most codes will adopt a modified Newton method where a linear solver is required at each nonlinear iteration.
The BE method can be a prototype for various flavors of implicit Runge-Kutta methods (IRK, DIRK, SDIRK, ESDIRK, etc.), Adams-Moulton methods, or Backward Differentiation Formula (BDF) methods, but there are fewer similarities between these methods than there is between the explicit methods.</p>
<p><strong>Time step cost and size:</strong>
Due to the need to solve a (non-)linear system of equations, one time step of an implicit method can be orders of magnitude more expensive than one time step of an explicit method.
If iterative solvers are employed, the cost of each step will also vary with the overall conditioning of the system from one time step to the next.</p>
<p>However, it is well-known that explicit solvers often have strict requirements for the stable time step size (e.g., <span class="math notranslate nohighlight">\(\Delta t \propto \Delta x^2\)</span> for FE discretization of heat equation).
By comparison, most implicit methods are either unconditionally stable or have much wider stability regions
For a given time interval and similar order of accuracy, an explicit method will usually take many more time steps than an implicit method, which can increase the accumulated roundoff error (this will depend on the particular schemes).
Also, if the increase in stable step size is large enough, the implicit method may end up requiring less walltime to solve the entire model.</p>
<p><strong>Memory usage:</strong>
Explicit and implicit schemes can have different requirements on the amount of RAM that is needed for the same overall problem size.
If we consider the FE and BE methods, both can be implemented with two vectors: one for <span class="math notranslate nohighlight">\(u^n\)</span> and one for <span class="math notranslate nohighlight">\(u^{n+1}\)</span>.
For the explicit method, this places no restrictions on the resulting solver algorithm: you can solve for <span class="math notranslate nohighlight">\(u^{n+1}\)</span> and then either copy it to <span class="math notranslate nohighlight">\(u^n\)</span> or swap the associated pointers in the code.
However, economizing memory in the implicit scheme limits your method to classical iterative methods like Newton-Gauss-Seidel, which may not offer satisfactory performance in your overall code.
More powerful solvers like Newton-Krylov methods will require more memory, but will allow the implicit method to converge quickly.</p>
<p>While not universally true, this leads to a rule of thumb that for equal numbers of stages or steps, an explicit scheme will require less memory than an implicit scheme.
However, low-order implicit schemes may be able to take significantly larger time steps than even high-order explicit schemes, which can equalize the overall cost.</p>
</section>
<section id="coupling-and-consistency">
<h4>Coupling and Consistency<a class="headerlink" href="#coupling-and-consistency" title="Link to this heading">#</a></h4>
<p>Comment about how hard it can be to solve multiple equations simultaneously.
Do you solve multiple small systems or one large system?</p>
</section>
<section id="semi-implicit-and-imex-methods">
<h4>Semi-Implicit and ImEx Methods<a class="headerlink" href="#semi-implicit-and-imex-methods" title="Link to this heading">#</a></h4>
<p>In semi-implicit and implicit-explicit (ImEx) methods, different terms in the governing equations are approximated by different implicit or explicit schemes.
These methods have a long history in the phase-field community and, as suggested by their name, behave “in between” explicit and implicit schemes.
For example, convex splitting methods for the Cahn-Hilliard equation naturally result in implicit and explicit terms.
Semi-implicit methods are also the default choice in Fourier pseudospectral methods.
In more general models, physics with “fast” time scales may be solved implicitly, while physics with “slow” time scales may be solved explicitly.</p>
<p>The resulting schemes are usually much cheaper than fully implicit methods.
The largest stable or accurate time step size will typically be reduced compared to an implicit scheme, but is usually much larger than an explicit scheme.</p>
</section>
<section id="time-step-adaptivity">
<h4>Time Step Adaptivity<a class="headerlink" href="#time-step-adaptivity" title="Link to this heading">#</a></h4>
<p>When choosing the time step size of an integrator, there is a need to balance computational cost (i.e., larger step size, fewer time steps, lower cost) and the numerical accuracy (smaller step size, better approximation of time derivatives, lower error, and improved solvability).
Just as we can adaptively refine and coarsen the mesh of a spatial discretization to improve accuracy or reduce the computational cost, we can also employ adaptive methods when choosing a time step.
In many Runge-Kutta and Rosenbrock methods, the scheme provides an embedded estimate of the error in the solution.
A weighted norm of this error can be compared to a specified tolerance, which decides if the time step is accepted or rejected, and then the step size can be adjusted by a PID controller or some other filter.
In multistep methods, we can derive estimates of the leading truncation error, which then allows us to check the accuracy of a step.
However, different methods will have different rules about how to change step size: Runge-Kutta methods can usually change the step size by large amounts every time step, but multistep methods often have to change by smaller amounts or only every few time steps.</p>
<p>When properly implemented, adaptive time stepping improves confidence in solution quality, minimizes the chance of your solution “exploding” from too large of a time step, and can save time with expensive schemes by reducing step size in fast-changing regions of time and increasing it when the dynamics are slower.</p>
</section>
<section id="general-guidelines">
<h4>General Guidelines<a class="headerlink" href="#general-guidelines" title="Link to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>For initial development, it is best to start with simpler schemes like Forward Euler. This will allow you to gain an understanding of your model’s behavior, check for bugs in the basic mechanics of the code, and start estimating the cost of simulations. If the model is inexpensive or you don’t plan to use the code more than a few times, a basic integrator may be all you need.</p></li>
<li><p>If you are forced to use small time steps on the scale of time you want to simulate, you might consider an implicit integrator (again, start with simpler schemes like BE or CN).</p></li>
<li><p>If your model contains varying time scales (e.g. from coupled physics, concentration-dependent mobility) and you have difficulty maintaining a stable time step or find that the convergence is unpredictable, adaptive time stepping will likely be helpful. If you are using explicit schemes, consider trying an embedded Runge-Kutta method. For implicit schemes, you might try a higher-order BDF method if your right-hand-side function is expensive to compute or a diagonally implicit Runge-Kutta method.</p></li>
<li><p>If you need to solve an elliptic governing equation simultaneously (<a class="reference external" href="https://pages.nist.gov/pfhub/benchmarks/benchmark6-hackathon.ipynb/">as in Benchmark 6</a>), the resulting system of differential-algebraic equations (DAEs) is likely to be very stiff. Even if the time-dependent portion is not expensive to evaluate, the cost of constantly performing the elliptic solve can be significant with explicit methods. Consider BDF methods, diagonally implicit or additive Runge-Kutta methods, or Rosenbrock methods.</p></li>
<li><p>For coupled physics, carefully examine how each equation is related. Some time-dependent terms may be less strongly coupled than others or be more costly to evaluate in a fully implicit scheme, so you might consider a semi-implicit or ImEx scheme such as an additive Runge-Kutta method.</p></li>
</ol>
<p>Many families of time integrators have variants that can choose the time step size adaptively.
Additionally, the Adams and BDF methods have implementations with variable order of accuracy.
<strong>If your code does not already provide time integration, many packages exist for various flavors of time steppers</strong>, including but not limited to <a class="reference external" href="https://github.com/LLNL/sundials">SUNDIALS</a>, <a class="reference external" href="https://petsc.org/release/docs/manualpages/TS/index.html">PETSc TS</a>, <a class="reference external" href="https://trilinos.github.io/tempus.html">Tempus</a>, and <a class="reference external" href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p>
</section>
</section>
<section id="choosing-linear-and-nonlinear-solvers-if-needed">
<h3>Choosing Linear and Nonlinear Solvers (If Needed)<a class="headerlink" href="#choosing-linear-and-nonlinear-solvers-if-needed" title="Link to this heading">#</a></h3>
<p>Depending on your spatial/temporal discretizations and whether you need to solve any elliptic governing equations, you may need to implement or choose a set of appropriate linear and nonlinear solvers.
<strong>Many codes will already provide solvers that work well for their packages.</strong>
For example, if you were implementing a model in FEniCS, the developers have already exposed options from PETSC’s nonlinear and linear solver interfaces and you can easily switch between different dense, sparse, and iterative methods.
Even if you are implementing your own code, <strong>solvers may already be available from the libraries you link to and you may not need to write your own.</strong>
For example, SUNDIALS provides a set of linear and nonlinear solvers that are already optimized for its time-stepping routines.</p>
<p>If you need to write your own solvers, we provide some general guidelines below.</p>
<section id="when-you-might-need-linear-or-nonlinear-solvers">
<h4>When You Might Need Linear or Nonlinear Solvers<a class="headerlink" href="#when-you-might-need-linear-or-nonlinear-solvers" title="Link to this heading">#</a></h4>
<p>The need for (non)linear solvers in a given code will depend on the equations you are solving and your choices of spatiotemporal discretizations.
As a simple example, we can consider incremental changes to a 1D Allen-Cahn-type model for a driven phase transformation (i.e., a simplified form of BM3).
For a spatial discretization with centered finite differences and time integration by Forward Euler, the equation at each point of the mesh will be of the form</p>
<div class="math notranslate nohighlight">
\[
\phi_i^{n+1} = \phi_i^n + \Delta t ( \phi_{i+1}^n - 2 \phi_i^n + \phi_{i-1}^n - g'(\phi_i^n) - Q p'(\phi_i^n) )
\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> corresponds to the time step of the solution, <span class="math notranslate nohighlight">\(i\)</span> corresponds to the grid points, <span class="math notranslate nohighlight">\(\Delta t\)</span> is the time step, <span class="math notranslate nohighlight">\(Q\)</span> is the driving force, and <span class="math notranslate nohighlight">\(g'\)</span> and <span class="math notranslate nohighlight">\(p'\)</span> are the derivatives of the double-well and interpolation function, respectively.
Note that we assume values of 1 for mobility, <span class="math notranslate nohighlight">\(\kappa / \Delta x^2\)</span>, and the well height.
All of the quantities on the right-hand side are known: we can evaluate each <span class="math notranslate nohighlight">\(\phi_i^{n+1}\)</span> directly without needing to perform any linear or nonlinear solvers.
This is sometimes referred to as “linearization through explicit time stepping.”</p>
<p>A common approach to improve time step stability of a PFM is to employ a convex split of the governing equations where we decompose the nonlinear terms as <span class="math notranslate nohighlight">\(g(\phi) = g_+ (\phi) + g_- (\phi)\)</span> and <span class="math notranslate nohighlight">\(p(\phi) = p_+ (\phi) + p_- (\phi)\)</span>, where <span class="math notranslate nohighlight">\(+\)</span> indicates the purely convex portion of the function and <span class="math notranslate nohighlight">\(-\)</span> is the remaining (presumably concave) portion.
Typically, we solve this convex-split approach by ImEx methods such as Forward-Backward Euler:</p>
<div class="math notranslate nohighlight">
\[
\phi_i^{n+1} - \Delta t ( \phi_{i+1}^{n+1} - 2\phi_i^{n+1} + \phi_{i-1}^{n+1} - g_+'(\phi_i^{n+1}) - Qp_+'(\phi_i^{n+1}) ) = \phi_i^n - \Delta t ( g_-'(\phi_i^n) + Qp_-'(\phi_i^n) )
\]</div>
<p>This system of equations is now semi-implicit in nature, but we can form the convex split such that the left-hand side is fully linear, e.g., <span class="math notranslate nohighlight">\(g_+(\phi) = a \phi^2\)</span> for <span class="math notranslate nohighlight">\(g(\phi) = \phi^2 (1-\phi)^2\)</span>.
As a result, we need a linear solver for this scheme (such as a tridiagonal LU decomposition) to obtain <span class="math notranslate nohighlight">\(\{\phi^{n+1}\}\)</span>, but no nonlinear solver.
We can use larger time step sizes than with Forward Euler, but we can easily “break” the system so that we don’t observe a monotonic decrease in free energy.</p>
<p>Lastly, we may choose to discretize this system by the Backward Euler method:</p>
<div class="math notranslate nohighlight">
\[
\phi_i^{n+1} - \Delta t (\phi_{i+1}^{n+1} - 2\phi_i^{n+1} + \phi_{i-1}^{n+1} - g'(\phi_i^{n+1}) - Qp'(\phi_i^{n+1})  = \phi_i^n
\]</div>
<p>The left-hand side is now fully implicit and nonlinear.
We will need to perform a nonlinear solve at each time step, and this may or may not require the solution of additional linear systems.</p>
</section>
<section id="types-of-nonlinear-solvers">
<h4>Types of Nonlinear Solvers<a class="headerlink" href="#types-of-nonlinear-solvers" title="Link to this heading">#</a></h4>
<p>Two of the most common types of nonlinear methods you will encounter are <strong>fixed-point methods</strong>, which solve problems of the form <span class="math notranslate nohighlight">\(G(u) = u\)</span>, and <strong>root finding methods</strong>, which solve problems of the form <span class="math notranslate nohighlight">\(F(u) = 0\)</span>.
We can usually convert fixed-point problems to root-finding problems by letting <span class="math notranslate nohighlight">\(F(u) = G(u) - u\)</span>, but the reverse conversion may not be as well-behaved and will be problem dependent.
These methods have some similarities in underlying concepts, but the resulting algorithms and implementation can vastly differ.</p>
<p>While not discussed here, another important class of nonlinear methods is Full Approximation Scheme (FAS) multigrid solvers.
In FAS, we obtain solutions of the system <span class="math notranslate nohighlight">\(A(u) = f\)</span> by relaxing the residual and its error on progressively coarsened grids, after which we interpolate a set of corrections onto the finer grid levels.
Depending on the forms of <span class="math notranslate nohighlight">\(A(u)\)</span> and <span class="math notranslate nohighlight">\(f\)</span>, this method can look like a fixed-point or root-finding method that can be applied to a wide range of systems, although the implementation can be quite complex.</p>
<p><strong>Fixed-Point Methods:</strong> A basic fixed-point method will often adopt the following approach:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, compute the nonlinear function, <span class="math notranslate nohighlight">\(G(u)\)</span></p></li>
<li><p>Calculate a new guess by <span class="math notranslate nohighlight">\(\tilde{u} = G(u)\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||u - \tilde{u}|| &lt; tol\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>This is often referred to as functional iteration or Picard iteration.
<strong>While simple to implement, this basic scheme may converge slowly or fail to converge at all.</strong>
There are schemes to accelerate the convergence of the series (e.g., Anderson Mixing, Aitken’s Delta-Squared Method), or we can linearize the nonlinear function about <span class="math notranslate nohighlight">\(\tilde{u}\)</span> as <span class="math notranslate nohighlight">\(G(\tilde{u}) \approx G(u) + \mathbf{J} (\tilde{u} - u)\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{J} = \nabla G(u)\)</span> is the Jacobian matrix of the nonlinear system.
The resulting <strong>linearized fixed-point method</strong> is then of the form:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, compute the nonlinear function, <span class="math notranslate nohighlight">\(G(u)\)</span></p></li>
<li><p>Solve the linear system <span class="math notranslate nohighlight">\((\mathbf{I} - \mathbf{J})\tilde{u} = G(u) - \mathbf{J}u\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||u - \tilde{u}|| &lt; tol\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>As a note, we may not need to explicitly assemble <span class="math notranslate nohighlight">\(\mathbf{J}\)</span>, or the associated linear solver in step (2) might arise “naturally” in the governing equations.
For example, a pointwise Jacobi-type fixed-point iteration for the fully-implicit 1D Allen-Cahn example can be written as</p>
<div class="math notranslate nohighlight">
\[
\tilde{\phi_i}^{n+1} = \frac{\phi_i^n + \Delta t (\phi_{i+1}^{n+1} + \phi_{i-1}^{n+1} - g'(\phi_i^{n+1}) + g''(\phi_i^{n+1})\phi_i^{n+1} - Q p'(\phi_i^{n+1}) + Q p''(\phi_i^{n+1}) \phi_i^{n+1} )}{1 + 2 \Delta t + \Delta t ( g''(\phi_i^{n+1}) + Q p''(\phi_i^{n+1}) )}
\]</div>
<p>where <span class="math notranslate nohighlight">\(g''\)</span> and <span class="math notranslate nohighlight">\(p''\)</span> are second derivatives of the respective functions.
This combines steps (1) and (2) into a single process as we sweep over the entire mesh to evaluate <span class="math notranslate nohighlight">\(\{\tilde{\phi}^{n+1}\}\)</span>.</p>
<p><strong>Root-Finding Methods:</strong> In many cases, a root-finding method will often adopt some sort of Newton-type method where we linearize the function through a Taylor expansion, obtain a correction to the solution, and then iterate until convergence.
For example, the classic <strong>Newton-Raphson method</strong> can be written as:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, calculate <span class="math notranslate nohighlight">\(F(u)\)</span> and its Jacobian matrix <span class="math notranslate nohighlight">\(\mathbf{J}\)</span></p></li>
<li><p>Correct the solution by solving the linear system <span class="math notranslate nohighlight">\(\delta u = - \mathbf{J}^{-1} F(u)\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||\delta u|| &lt; tol\)</span></p></li>
<li><p>Assemble the next guess as <span class="math notranslate nohighlight">\(\tilde{u} = u + \delta u\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>Immediately, we can recognize a similarity between the Newton-Raphson approach and the linearized fixed-point iteration: both perform a linearization about the current value of the function for a guess of <span class="math notranslate nohighlight">\(u\)</span> and solve a linear system to obtain the next guess.
(Note: this is part of why we say that fixed-point solutions can be obtained through an equivalent root-finding method.)</p>
<p>Assembling <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> and solving the linear system for <span class="math notranslate nohighlight">\(\delta u\)</span> can be exceptionally expensive.
However, if <em>iterative linear solvers</em> are employed, a few iterations of the linear method can significantly reduce the residual of the nonlinear system.
This leads to the formation of an <strong>inexact Newton method</strong>:</p>
<ol class="arabic simple">
<li><p>For the current guess of <span class="math notranslate nohighlight">\(u\)</span>, calculate <span class="math notranslate nohighlight">\(F(u)\)</span> and its Jacobian matrix <span class="math notranslate nohighlight">\(\mathbf{J}\)</span></p></li>
<li><p>Perform <span class="math notranslate nohighlight">\(k\)</span> iterations of an iterative linear solver to approximately solve <span class="math notranslate nohighlight">\(\mathbf{J} \delta u = - F(u)\)</span></p></li>
<li><p>Converged if <span class="math notranslate nohighlight">\(||\delta u|| &lt; tol\)</span></p></li>
<li><p>Assemble the next guess as <span class="math notranslate nohighlight">\(\tilde{u} = u + \delta u\)</span></p></li>
<li><p>Assign <span class="math notranslate nohighlight">\(u = \tilde{u}\)</span></p></li>
<li><p>If not converged, go to (1)</p></li>
</ol>
<p>We may make further modifications to this algorithm to potentially improve performance, such as only evaluating <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> every few iterations.
If we employ Krylov methods for step (2), we do not necessarily need to form the Jacobian and instead only need to evaluate matrix-vector products <span class="math notranslate nohighlight">\(\mathbf{J} \delta u\)</span>.
This leads to the popular and powerful <strong>Jacobian-Free Newton-Krylov (JFNK) method</strong>, which is employed by many community codes and software libraries.
Also common are <strong>Newton-Multigrid methods</strong>, where a few multigrid iterations are performed in step (2).
We may further try to “globalize” the solution by combining the inexact Newton method with a line-search method to find an optimal decrease in the residual, usually under the condition <span class="math notranslate nohighlight">\(||F(u + \alpha \delta u)|| &lt; ||F(u)||\)</span> with <span class="math notranslate nohighlight">\(\alpha\)</span> between 0 and 1.</p>
<p>If we examine the pointwise Jacobi scheme for the fully-implicit Allen-Cahn, we see that this is essentially an inexact Newton method that does one inner iteration of Jacobi relaxation at each outer Newton iteration.
Thus, we can see that there are some general similarities between these broad classes of nonlinear methods.
<strong>However, it is rare that the resulting algorithms are exactly equivalent to each other, and it can be nontrivial to switch from a fixed-point to a root-finding solver.</strong></p>
</section>
<section id="types-of-linear-solvers">
<h4>Types of Linear Solvers<a class="headerlink" href="#types-of-linear-solvers" title="Link to this heading">#</a></h4>
<p>In the above discussion, we’ve observed that linear solvers are necessary as a result of the discretization of the governing equations or because we need to solve a nonlinear system of equations.
<strong>The choice of solver will depend on the size of your simulation and whether you can easily evaluate a Jacobian matrix of your system.</strong>
Up to a few thousand unknowns, direct linear solvers (e.g. LAPACK, UMFPACK, cuSolver, SuperLU) that offer dense or sparse variants of typical methods like LU decomposition and QR factorization will often be efficient, provided it is easy to evaluate the entries of the Jacobian matrix.
However, it is important to remember that dense direct solvers typically scale O(n^2) for required memory and O(n^3) for the number of operations and quickly become unsolvable.
The scalability of sparse direct solvers will depend on the particular method and the implementing library.
For millions or billions of unknowns across large numbers of CPUs or GPUs, iterative solvers are often necessary.
Here, a wide range of options exists; in particular, relaxation, multigrid, and Krylov methods all parallelize well and have been employed in a variety of community codes and numerical libraries.</p>
<p>Some of the simplest iterative methods are stationary relaxation methods such as the Jacobi, Gauss-Seidel, and (Symmetric) Successive Over-Relaxation methods.
Classically, these are derived by splitting the Jacobian matrix as <span class="math notranslate nohighlight">\(J = D - E - F\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> is the diagonal, <span class="math notranslate nohighlight">\(-E\)</span> is the purely lower triangular portion, and <span class="math notranslate nohighlight">\(-F\)</span> is the purely upper triangular portion.
Depending on how we manipulate <span class="math notranslate nohighlight">\(D\)</span>, <span class="math notranslate nohighlight">\(E\)</span>, and <span class="math notranslate nohighlight">\(F\)</span>, we obtain the above methods or their symmetric variants; however, <strong>we may not need to directly form the Jacobian or its submatrices</strong>, as we observed in the above Allen-Cahn example.
<strong>The simplicity and low memory requirements of relaxation methods make them attractive methods, but they often converge slowly.</strong>
The convergence can be improved by employing multigrid methods: <strong>Geometric Multigrid methods converge rapidly by applying relaxation methods</strong> on multiple levels of structured grids and are popular solvers for a wide range of problems.</p>
<p>Krylov methods (e.g. Conjugate Gradient, GMRES, BiCGSTAB, TFQMR) are a powerful family of linear solvers that form a subspace from a linear operator (such as the Jacobian) and the residual vectors of the system (this is a very simplified explanation).
While these methods can be formulated to directly use the Jacobian, <strong>most only require the evaluation of Jacobian-vector products</strong>, which is what leads to the “Jacobian-free” nature of JFNK methods.
This Jacobian-vector product is typically evaluated in either a functional form if the Jacobian can be easily obtained (e.g., the kernel of a linear heat equation), but for methods such as JFNK, <strong>the Jacobian-vector product is readily approximated by the Gateaux derivative</strong>.
These methods can, therefore, be <strong>straightforward to implement, even with intricate linear functions</strong>.
However, <strong>convergence is strongly dependent on the condition number of the operator matrix.</strong></p>
<p>The performance of Krylov methods can be improved through <strong>preconditioning</strong>.
Here, we form an approximation to the overall Jacobian matrix, <span class="math notranslate nohighlight">\(\mathbf{M} \approx \mathbf{J}\)</span>.
Depending on the exact method, we will then find solutions to some linear system of the residual, e.g., <span class="math notranslate nohighlight">\(\mathbf{M} z = r\)</span>, at certain points of the algorithm.
If done correctly, the computational time and the number of iterations to reach the desired tolerance will decrease.
The preconditioner, therefore, needs to (1) be easy to form and assemble, (2) be easy to solve and apply, and (3) should capture the essential physics of the system.
<strong>Designing preconditioners is problem-dependent and can have a huge impact on the overall model performance</strong>.
Many possible options have been applied by the phase-field community, including relaxation methods (e.g., Jacobi, Gauss-Seidel), multigrid methods (both geometric and algebraic), incomplete LU and Cholesky factorizations, sparse approximate inverses, and multiplicative or additive Schwarz methods.
<strong>You will likely need to experiment with the best preconditioner for your model,</strong> which can require a significant amount of time if your libraries don’t already provide them.</p>
<p>In summary: when choosing linear solvers, <strong>it is not trivial to switch from a relaxation or multigrid method to a Krylov method (or vice versa)</strong>, although the former methods can be used as preconditioners for the latter.
Changing from one Krylov method to another can be relatively straightforward, but <strong>some Krylov methods only apply to symmetric positive definite matrices</strong>.
Modifying the preconditioner can have varying difficulties: switching from a Jacobi to a Gauss-Seidel preconditioner is trivial, but switching to an ILU preconditioner might require much more effort.</p>
</section>
</section>
<section id="choosing-an-appropriate-parallelism-approach">
<h3>Choosing an appropriate parallelism approach<a class="headerlink" href="#choosing-an-appropriate-parallelism-approach" title="Link to this heading">#</a></h3>
<p>(Discuss distributed vs shared, CPU vs GPU)</p>
<section id="distributed-memory">
<h4>Distributed memory<a class="headerlink" href="#distributed-memory" title="Link to this heading">#</a></h4>
<p>(pretty much just MPI, also mention UPC or Legion or Charm++?)</p>
</section>
<section id="shared-memory">
<h4>Shared memory<a class="headerlink" href="#shared-memory" title="Link to this heading">#</a></h4>
<p>CPU/GPU, performance portability layers</p>
</section>
</section>
</section>
<section id="choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself">
<h2>Choosing appropriate numerical libraries and/or what to write yourself<a class="headerlink" href="#choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself" title="Link to this heading">#</a></h2>
<p>The phase-field and broader scientific computing community have developed many libraries that you may choose to use as you implement your phase-field model. As you decide which methods you want to use, an important consideration is whether you intend to write code for certain functionality yourself or whether you want to use an existing library/framework for that functionality.</p>
<section id="investigate-existing-solutions-before-writing-your-own">
<h3>Investigate existing solutions before writing your own<a class="headerlink" href="#investigate-existing-solutions-before-writing-your-own" title="Link to this heading">#</a></h3>
<p>Before coding your own functionality, it is always a good idea to explore what solutions already exist. Researchers have devoted their careers to developing some scientific computing libraries and frameworks, and they may be better for your application than something you write yourself. Even in the cases where you <em>could</em> write code for some functionality yourself that is an improvement over existing solutions, it may not be worth your time to actually do so. Finally, even if you decide that your best course is to write your own functionality, learning about other solutions may inform your approach and/or help you frame to potential users what distinguishes your implementation.</p>
<section id="existing-phase-field-codes-and-frameworks">
<h4>Existing phase-field codes and frameworks<a class="headerlink" href="#existing-phase-field-codes-and-frameworks" title="Link to this heading">#</a></h4>
<p>PFHub maintains a <a class="reference external" href="https://pages.nist.gov/pfhub/codes/">list of open source phase-field codes and frameworks</a>, one or more of which may fit your needs.</p>
</section>
<section id="consider-how-existing-libraries-interact">
<h4>Consider how existing libraries interact<a class="headerlink" href="#consider-how-existing-libraries-interact" title="Link to this heading">#</a></h4>
<p>Some libraries are packages in a larger collection where interfaces for interoperability have already been developed. Such large collections include <a class="reference external" href="https://trilinos.github.io/">Trilinos</a>, <a class="reference external" href="https://petsc.org/release/">PETSc</a>, and <a class="reference external" href="https://github.com/hypre-space/hypre">hypre</a>/<a class="reference external" href="https://github.com/LLNL/SAMRAI">SAMRAI</a>/<a class="reference external" href="https://sundials.readthedocs.io/en/latest/">SUNDIALS</a>. Staying within an ecosystem may reduce your time to solution and will keep you on a well-traveled path if you reach out to developers or a user community for help.</p>
</section>
<section id="consider-local-expertise">
<h4>Consider local expertise<a class="headerlink" href="#consider-local-expertise" title="Link to this heading">#</a></h4>
<p>An important consideration for choosing a library or framework is who else uses it. If many other researchers in your organization use a particular library/framework, you may want to as well – when you run into issues, they might be able to help you (and vice versa).</p>
</section>
</section>
<section id="consider-licensing">
<h3>Consider licensing<a class="headerlink" href="#consider-licensing" title="Link to this heading">#</a></h3>
<p>Another consideration for choosing a library or framework is what the license terms are. For commercial software, license terms may dictate that a new license must be bought for each CPU core being used. With paid software, you may also want to consider the future of your work, even if you have access to that software now, that may not be true if you move institutions, your institution changes what they buy, etc. Other people who would be interested in using code that you develop would also have to pay for the underlying software.</p>
<p>For open-source libraries and frameworks, a wide variety of open-source licenses exist. While a discussion of the differences between these licenses is out of the scope of this document, the details of the license may constrain how you can use the library/framework and how you can distribute derivative works. One reference for open-source licenses is the <a class="reference external" href="https://opensource.org/licenses">Open Source Initiative</a>. The terms of these licenses can be confusing and disputed. The legal department at your institution may be able to offer advice.</p>
</section>
</section>
<section id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Link to this heading">#</a></h2>
<section id="solver-methods">
<h3>Solver Methods:<a class="headerlink" href="#solver-methods" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Y. Saad. <em>Iterative Methods for Sparse Linear Systems, Second Edition.</em> Society for Industrial and Applied Mechanics, 2003.</p></li>
<li><p>W.L. Briggs, V. Emden Henson, S.F. McCormick. <em>A Multigrid Tutorial, Second Edition.</em> Society for Industrial and Applied Mechanics, 2000.</p></li>
<li><p>D.A. Knoll, D.E. Keyes. “Jacobian-free Newton-Krylov methods: a survey of approaches and applications.” <em>J. Comput. Phys.</em> 193 (2004) 357-397.</p></li>
</ol>
<hr class="docutils" />
<p>Topics we want to move to other sections:</p>
<ul class="simple">
<li><p>Conservation laws and symmetries (Model Formulation)</p></li>
<li><p>Have an expectation going in (Model Formulation)</p></li>
<li><p>Add pieces of the model one part at a time during debugging (Software Development)</p></li>
<li><p>Ensure physical expectations are respected (Software Development)</p></li>
</ul>
<hr class="docutils" />
<p>OLD TEXT</p>
<p>Contributors: Stephen DeWitt, Alex Chadwick</p>
<p>Alex Chadwick, Steve Dewitt</p>
<ul class="simple">
<li><p>Carefully consider your spatial discretization scheme (FFT, FD, FV, FEM)</p></li>
<li><p>Consider your temporal discretization scheme and use temporal error estimation when possible (implicit, explicit, etc.)</p></li>
<li><p>Identify relevant conservation laws and symmetries for your model and carefully ensure they are respected even after long times</p></li>
<li><p>Start small and add complexity. Add pieces to the model one part at a time during debugging. Check to see if it is working, then add more, then test again.</p></li>
<li><p>Have an expectation going in (back of the envelope, consider basic physics), and if it doesn’t do that, figure out why.</p></li>
</ul>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./bp-guide-gh"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ch1-model-formulation.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Model Formulation</p>
      </div>
    </a>
    <a class="right-next"
       href="ch3-data-generation-and-curation.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Data Generation and Curation</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-collection-of-numerical-methods">Choosing an appropriate collection of numerical methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#start-simple-then-selectively-move-to-more-complex-methods">Start simple, then selectively move to more complex methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-spatial-discretization">Choosing a spatial discretization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-difference">Finite difference</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-volume">Finite volume</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-element">Finite element</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fourier-pseudospectral">Fourier pseudospectral</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-discretization-summary-table">Spatial Discretization Summary Table</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#adaptive-mesh-refinement">Adaptive Mesh Refinement</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#methods-for-applying-boundary-conditions-on-internal-boundaries">Methods for Applying Boundary Conditions on Internal Boundaries</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-a-time-integration-method">Choosing a Time Integration Method</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#explicit-vs-implicit-methods">Explicit vs. Implicit Methods</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coupling-and-consistency">Coupling and Consistency</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#semi-implicit-and-imex-methods">Semi-Implicit and ImEx Methods</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#time-step-adaptivity">Time Step Adaptivity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-guidelines">General Guidelines</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-linear-and-nonlinear-solvers-if-needed">Choosing Linear and Nonlinear Solvers (If Needed)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#when-you-might-need-linear-or-nonlinear-solvers">When You Might Need Linear or Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-nonlinear-solvers">Types of Nonlinear Solvers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types-of-linear-solvers">Types of Linear Solvers</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-an-appropriate-parallelism-approach">Choosing an appropriate parallelism approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#distributed-memory">Distributed memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#shared-memory">Shared memory</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-appropriate-numerical-libraries-and-or-what-to-write-yourself">Choosing appropriate numerical libraries and/or what to write yourself</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#investigate-existing-solutions-before-writing-your-own">Investigate existing solutions before writing your own</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#existing-phase-field-codes-and-frameworks">Existing phase-field codes and frameworks</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-how-existing-libraries-interact">Consider how existing libraries interact</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-local-expertise">Consider local expertise</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#consider-licensing">Consider licensing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further reading</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solver-methods">Solver Methods:</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By PFHub Workshop Community
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>